
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="sengwoolee&#39;s development blog">
    <title>sengwoolee&#39;s development blog</title>
    <meta name="author" content="sengwoolee">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://sengwoolee.dev","author":{"@type":"Person","name":"sengwoolee","sameAs":["https://github.com/sengwoolee","http://stackoverflow.com/users/10808643","mailto:leesengwoo555@gmail.com"],"image":"sengwoolee.png"},"name":"sengwoolee's development blog","description":"sengwoolee's development blog","url":"https://sengwoolee.dev"}</script>
    <meta name="description" content="sengwoolee&#39;s development blog">
<meta property="og:type" content="blog">
<meta property="og:title" content="sengwoolee&#39;s development blog">
<meta property="og:url" content="https://sengwoolee.dev/index.html">
<meta property="og:site_name" content="sengwoolee&#39;s development blog">
<meta property="og:description" content="sengwoolee&#39;s development blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="sengwoolee">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://sengwoolee.dev/assets/images/sengwoolee.png"/>
    
    
    
    
    <script data-ad-client="ca-pub-2734957826003555" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            sengwoolee&#39;s development blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/sengwoolee.png" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/sengwoolee.png" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">sengwoolee</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Software Developer, Project Manager, Data Analyst, Quality Assurance</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="홈"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">홈</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/2020/04/04/introduce-myself/"
                            
                            rel="noopener"
                            title="어바웃"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">어바웃</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/sengwoolee"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Github"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Github</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users/10808643"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:leesengwoo555@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/31/2020-05-31-2/"
                            aria-label=": 객체지향 방법론"
                        >
                            객체지향 방법론
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-31T22:49:40+09:00">
	
		    May 31, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Development/">Development</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="객체지향-방법론"><a href="#객체지향-방법론" class="headerlink" title="객체지향 방법론"></a>객체지향 방법론</h3><p>객체란 사물을 논리적으로 추상화한 것이다. 예를들어 자동차가 있다고 가정할 때 자동차는 바퀴, 유리창, 사이드미러, 기어, 엑셀, 브레이크 등 눈으로 볼 수 있는 수천가지 부품으로 구성돼 있다. 추상화란 우리가 관심 있는 부분만 추려내는 것이다. 자동차 객체를 만드는데 다른건 다 필요없고 앞뒤로 움직이는 것만 관심이 있다면 기어, 엑셀, 브레이크 속성과 전진, 후진, 정지, 가속 기능만 있으면 된다. 따라서 객체는 사물에 대해 관심 있는 부분만 추려내 추상화한 것이다.</p>
<p>객체는 데이터와 기능을 동시에 가지고 있다. 하나의 객체는 다른 객체가 가지고 있는 데이터와 기능을 사용할 수 있고 이런 능력은 객체간 결합을 가능하게 한다. 객체지향 방법론은 객체의 특성을 활용하여 객체를 생성하고 구체화하여 프로그램을 진행한다. 정보공학 방법론처럼 데이터와 프로세스를 따로 설계하지 않고 데이터와 프로세스를 모두 객체에 담아 오로지 객체의 관점에서 프로그램을 개발한다.</p>
<p>객체지향 방법론에서는 분석, 설계, 구현의 전 과정을 객체 중심으로 진행한다. 심지어 데이터를 저장하는 테이블도 따로 설계하지 않고 데이터 객체로 설계한다. 데이터는 결국 데이터베이스에 저장되는데 만일 데이터베이스가 객체행 데이터베이스라면 별다른 변환과정 없이 데이터 객체를 그대로 저장하면 되지만 관계형 데이터베이스를 사용한다면 객체를 관계형 테이블로 변환하는 과정이 필요하다. 이 과정을 객체-관계 간 매핑이라고 한다. 현재 대부분의 회사에서 관계형 데이터베이스를 사용하고 있기 때문에 객체-관계 간 매핑은 필수적인 과정이라고 할 수 있다.</p>
<p>객체지향 방법론은 높은 재사용성과 안정성을 갖고 있다는 단점이 있으나 관계형 데이터베이스로 구성되어 있는 현재 산업계에서 객체-관계 간 매핑 과정이 필수적이기 때문에 활발하게 사용되지는 않는다. 관계형 데이터베이스에서 제공하는 SQL은 풍부한 기능을 가지고 있어 많은 개발자들이 이 분야에서 지식과 노하우를 축적하고 있다. 이 또한 관계형 데이터베이스에서 객체형 데이터베이스로의 이전을 가로막는 장애물이 되고 있다.</p>
<p>많은 프로젝트에서 자바와 같은 객체지향 언어를 사용하기 때문에 프로세스 설계 과정에서는 객체지향 개발 방법론 개념이 많이 사용되고 있으며 데이터 설계 과정에서는 기존의 정보공학 방법론이 많이 사용된다. 프로그램은 객체지향 언어를 사용하고 데이터베이스는 관계형으로 설계한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/31/2020-05-31-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/31/2020-05-31-1/"
                            aria-label=": 정보공학 방법론"
                        >
                            정보공학 방법론
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-31T00:15:50+09:00">
	
		    May 31, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Development/">Development</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="정보공학-개발-방법론"><a href="#정보공학-개발-방법론" class="headerlink" title="정보공학 개발 방법론"></a>정보공학 개발 방법론</h3><ul>
<li>정보공학 개발 방법론의 절차<br>ISP(Information Strategy Planning): 정보전략계획 - 기업의 중장기 정보화 전략 수립<br>BAA(Business Area Analysis): 업무영역분석 - 업무영역별 데이터와 프로세스 모델링, 연관분석<br>BSD(Business System Design): 업무시스템설계 - 프로세스와 데이터 설계<br>SC(System Construction): 시스템구축 - 데이터 상세설계, 프로그램 코딩</li>
</ul>
<p>정보공학 개발 방법론은 비즈니스 시스템 규모 성장과 소프트웨어 공학 발전에 따라 1980년대 중반에 등장한 방법론으로 기업의 전사적인 관점에서 출발해 데이터 중심으로 시스템을 구축하는 방법론이다. 기업의 중장기 정보화 전략을 수립하는 ISP와 업무 영역을 분석하는 BAA(Business System Design) 그리고 시스템을 구축하는 SC(System Construction) 단계로 구성된다.</p>
<p>ISP단계에서는 기업의 경영전략을 뒷받침할 수 있는 정보화 전략을 수립하기 위해 업무프로세스와 시스템을 분석하고 미래 아키텍처와 전략계획을 수립하게 된다.</p>
<p>BAA단계에서는 기업의 업무 현황을 분석해서 개념 수준의 데이터와 프로세스를 설계하는 업무분석 단계이다.</p>
<p>BSD단계는 실질적으로 시스템을 설계하는 단계로 우리가 많이 사용하고 있는 논리적 ER다이어그램으로 데이터를 설계하고 분할 다이어그램 액션 다이어그램 의존 다이어그램을 사용해 프로세스를 설계한다.</p>
<p>SC단계에서는 물리적 데이터베이스를 설계하고 BSD단계에서 작성한 산출물을 바탕으로 프로그램을 개발하게 된다. 이론적인 정보공학 방법론에서는 BSD단계에서 작성한 산출물을 바탕으로 프로그램 코드를 생성할 수 있는데, 대부분의 프로젝트에서는 설계문서만 만들고 코드는 개발자가 직접 만드는 방식으로 개발을 진행한다.</p>
<ul>
<li>정보공학 개발 방법론의 특징<br>ISP 중심 - 기업의 경영전략을 지원하기 위한 IT 전략수립에서 출발<br>데이터 중심 - 비즈니스의 중심은 데이터, 데이터 관점의 설계<br>공학적 접근 - Case Tool과 같은 자동화 도구 사용 설계 후 코드 자동생성</li>
</ul>
<p>정보공학 개발 방법론은 다양한 특징을 가지고 있지만 대표적으로 다음의 세개로 요약할 수 있다. 첫째 정보공학 개발 방법론은 ISP중심이다. ISP를 통해 기업 전체적인 업무와 정보화 현황을 정리한 다음 시스템 구축을 위한 계획을 수립한다. 둘째로 데이터 중심 방법론이다. 비즈니스의 중심은 데이터에 있다고 생각하고 IT도 데이터 관점으로 설계한다. 마지막으로 공학적으로 접근한다는 특징을 가지고 있다. 케이스 툴과 같은 자동화 도구를 통해 설계하고 코드를 자동으로 생성한다. 생성된 코드는 프로그램으로 동작하지 않는다. 하지만 프로그램이 가져야 하는 전체적인 윤곽을 잡아주는 역할을 한다.</p>
<p>현재 산업계에서 가장 많이 사용하는 방법론은 정보공학 방법론이다. 기업에서 3~5년 주기로 ISP 프로젝트를 통해 정보화 전략을 수립하고 그에 따른 정보 시스템을 구축한다. 기업 업무 중심에는 데이터베이스가 있으면 시스템은 데이터를 어떻게 하면 잘 쌓을지 그리고 어떻게 데이터를 활용해 기업의 생산성을 높일지 고민하면서 발전하고 있다. 지금 화두가 되는 인공지능 기술도 기업에서 쌓아놓은 데이터 기반 하에 성능을 발휘할 수 있다.</p>
<p>프로젝트 관점에서 정보공학 방법론을 살펴보면 실제 프로젝트 개발 과정에서 필요한 산출물의 종류는 그렇게 많지 않다. 설계 시 스토리보드, 데이터 설계서, UI 설계서 등을 작성하고 개발 과정에서는 이를 바탕으로 물리적 테이블과 프로그램 코드가 만들어진다. 이 관점에서 BAA에 해당하는 요구분석 단계에서는 요구사항 명세서가 만들어지고 BSD에 해당하는 시스템 설계 단계에서는 논리 ERD와 업무 프로세서를 설명하는 프로세스 구조도/흐름도가 만들어 진다. 그리고 SC에 해당하는 개발 단계에서는 물리 ERD, UI, 프로그램 코드가 개발된다.</p>
<p>정보공학 방법론은 일반적으로 수행하는 개발방식이 정보공학 방법론의 간소화 버전이라 생각하면 된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/31/2020-05-31-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/30/2020-05-30-1/"
                            aria-label=": 소프트웨어 개발 방법론"
                        >
                            소프트웨어 개발 방법론
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-30T23:49:48+09:00">
	
		    May 30, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Development/">Development</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="소프트웨어-개발-방법론"><a href="#소프트웨어-개발-방법론" class="headerlink" title="소프트웨어 개발 방법론"></a>소프트웨어 개발 방법론</h3><ul>
<li>소프트웨어 개발 방법론의 구성<br>작업절차: 소프트웨어를 진행할 때 이루어지는 작업의 순서<br>작업방법: 각 단계별 작업마다 수행해야 할 일(누가, 언제, 무엇을)<br>산출물: 단계별로 나오는 산출물(설계서, 명세서)<br>관리: 개발 진행을 어떻게 제어하고 감독할 것인지<br>기법: 단계별 작업 시 사용하는 기술, 기법(DFD, ERD, Use Case)<br>도구: 사용하는 기법 별 지원 도구(PowerPoint, Excel, ERWin)</li>
</ul>
<p>소프트웨어 생명주기 관리 모델에서는 포르젝트가 어떤 순서로 진행될지 그리고 중간에 어떤 산출물을 점검할 지에 대해 주로 관심을 가졌다면, 소프트웨어 개발 방법론은 소프트웨어를 어떻게 만들지에 대해 관심을 가진다. 따라서 개발 방법론에서는 단계별 산출물 뿐만 아니라 산출물은 누가 어떤 순서로 어떻게 만들어야 하는지 그리고 어떤 도구를 사용해야 하는지 구체적으로 정의하고 있다. 학교에서 배우는 소프트웨어 공학이 산업계에서 실무적으로 구현된 결과물이 개발방법론이라고 할 수 있다.</p>
<ul>
<li>소프트웨어 개발 방법론의 종류<br>정보공학 방법론<br>객체지향 방법론<br>CBD 방법론<br>애자일 방법론</li>
</ul>
<p>소프트웨어 개발방법론은 정보공학 방법론, 객체지향 방법론, CBD(Component Base Development) 방법론, 애자일 방법론이 이렇게 크게 4가지로 나눌 수 있다. 산업계에는 다양한 개발방법론이 나와있고 대규모 IT회사에는 자체적인 개발방법론을 보유하고 있지만, 이는 완전히 새로운 개념이 아니라 앞서 열거한 4가지 개발 방법론의 단점을 보완하거나 각각의 방법론의 장점을 따와 합성한 것들이 대부분이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/30/2020-05-30-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/26/2020-05-26-1/"
                            aria-label=": SOLID - 단일 책임 원칙(Single Responsibility Principle)"
                        >
                            SOLID - 단일 책임 원칙(Single Responsibility Principle)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-26T23:19:34+09:00">
	
		    May 26, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Development/">Development</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="단일-책임-원칙-Single-Responsibility-Principle"><a href="#단일-책임-원칙-Single-Responsibility-Principle" class="headerlink" title="단일 책임 원칙(Single Responsibility Principle)"></a>단일 책임 원칙(Single Responsibility Principle)</h3><p>객체는 단 하나의 책임만을 가져야 한다. 책임이란 객체가 할수 있는 것, 해야 하는 것을 말한다.</p>
<p>예를들어 학생 클래스가 수강 과목을 추가하거나 조회하고 데이터베이스에 객체 정보를 저장하거나 데이터베이스에서 객체 정보를 읽는 작업도 처리하고 성적표와 출석부를 출력하는 일도 한다고 가정했을 때 이런 경우 학생 클래스의 코드는 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCourses</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCourses</span><span class="params">(Course c)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">load</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOnReportCard</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOnAttendanceBook</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>현재 코드의 경우 Student 클래스는 너무 많은 책임을 수행해야 한다. 이는 곧 변경될 여지가 많다는 것이다. 현재 Student 클래스는 할당된 책임 중 가장 잘할 수 있는 것은 수강 과목을 추가하고 조회하는 일이다.</p>
<p>DB에 학생 정보를 저장하고 DB로부터 읽는 일이나 성적표와 출석부에 출력하는 일은 Student 클래스가 아닌 다른 클래스가 더 잘할 수 있는 여지가 많다. 따라서 Student 클래스에는 수강 과목을 추가하고 조회하는 책임을 수행하도록 하는 것이 SRP를 따르는 설계다.</p>
<p>설계 원칙을 학습하는 이유는 예측못한 변경사항에 유연하고 확장성 있도록 시스템 구조를 설계하기 위함이다. 즉 가능한 한 영향을 받는 부분을 줄여야 한다. 어떤 클래스가 잘 설계되었는지를 판단하려면 언제 변경되어야 하는지를 묻는것이 좋다.</p>
<p>현재의 Student 클래스가 언제 변경되어야 하는지를 알아보려면 변경 이유를 찾아보는 것이 좋다.</p>
<ul>
<li>DB의 스키마가 변경된다면 Student 클래스도 변경되어야 하는가?</li>
<li>학생이 지도 교수를 찾는 기능이 추가되어야 한다면 Student 클래스는 영향을 받는가?</li>
<li>학생 정보를 성적표와 출석부 이외의 형식으로 출력해야 한다면 어떻게 해야 하는가?</li>
</ul>
<p>3가지 모두 Student 클래스를 변경해야 하는 이유가 된다.</p>
<p>또한 책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합된 가능성이 높아진다.</p>
<p>예를 들어 현재 수강 과목을 조회하는 코드(getCourse 메서드)와 DB에서 학생 정보를 가져오는 코드(load 메서드) 중 어딘가가 연결될 수도 있고, 학생이 수강 과목을 추가하는 코드(addCourse 메서드)와 DB에 학생 정보를 갱신하는 코드(save 메서드)가 서로 연결될 수도 있다.</p>
<p>이런 경우 DB 스키마의 변화가 학생의 고유한 기능(getCourses 메서드, addCourse 메서드)을 구현한 코드에 변화를 필요하게 할 수도 있다.</p>
<h3 id="책임-분리"><a href="#책임-분리" class="headerlink" title="책임 분리"></a>책임 분리</h3><p>Student 클래스는 여러 책임을 수행하므로 Student 클래스의 도움을 필요로 하는 코드도 많을 수 밖에 없다.</p>
<p>학생의 수강 과목 목록을 사용해 어떤 일을 수행하는 코드도 Student 클래스의 도움을 필요로 하며, 신입생 정보를 DB에 기록하는 데도 Student 클래스를 필요로 할 수 있다. 또한 성적표와 출석부를 필요로 하는 코드도 Student 클래스를 사용할 수 있다.</p>
<p>이런 이유 때문에 Student 클래스에 변경사항이 생기면 Student 클래스를 사용하는 코드와 전혀 관계가 없더라도 직접 또는 간접적으로 사용하는 모든 코드를 다시 테스트해야 한다. </p>
<p>성적표에 학생을 표시하는 기능에 변경사항이 생기면 수강 과목을 조회하거나 등록하는 기능을 사용하는 코드도 다시 테스트해야 한다는 의미다. 이와 같이 어떤 변화가 있을 때 해당 변화가 기존 시스템의 기능에 영향을 주는지 평가하는 테스트를 회귀테스트라 한다.</p>
<p>모든 코드를 테스트하는 문제를 해결하려면 한 클래스에서 단 하나의 책임만 수행하도록 해 변경 사유가 될 수 있는 것을 하나로 만들어야 한다. 이를 책임 분리라 한다.</p>
<p>Student 클래스의 경우 변경 사유가 될 수 있는 것은 학생의 고유 정보, DB 스키마, 출력 형식의 변화 등 3가지다.</p>
<p>따라서 Student 클래스는 학생 고유의 역할을 수행하게끔 변경하고 학생 클래스의 인스턴스를 DB에 저장하거나 읽어들이는 역할을 담당하는 학생 DAO 클래스, 출석부와 성적표에 출력을 담당하는 성적표 클래스와 출석부 클래스로 분리하는 편이 좋다.</p>
<p>클래스들이 책임을 적절하게 분담하도록 변경하면 어떤 변화가 생겼을 때 영향을 최소화할 수 있다.</p>
<h3 id="산탄총-수술"><a href="#산탄총-수술" class="headerlink" title="산탄총 수술"></a>산탄총 수술</h3><p>지금까지는 한 클래스가 여러 가지 책임을 가진 상황이었다. 그런데 하나의 책임이 여러 개의 클래스들로 분산되어 있는 경우에도 단일 책임 원칙에 입각해 설계를 변경해야 하는 경우도 있다.</p>
<p>어떤 변경이 있을 때 하나가 아닌 여러 클래스를 변경해야 한다는 것이다.</p>
<p>클래스 하나하나를 모두 변경하지 않으면 프로그램이 정상적으로 동작하지 않고 에러가 발생할 수 있다. 하나의 책임이 여러 개의 클래스로 분리되어 있는 예는 로깅, 보안, 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능이 대표적이다.</p>
<p>횡단 관심에 속하는 기능은 대부분 시스템 핵심 기능(하나의 책임) 안에 포함되는 부가 기능(여러 개의 클래스로 분리)이다.</p>
<p>보통 부가 기능에 변경사항이 발생하면 해당 부가 기능을 실행하는 모든 핵심 기능에도 변경사항이 적용되어야 한다.</p>
<p>가령 시스템에서 실행하는 특정 메서드들의 실행 로그를 DB에 저장한다고 생각해보면 분명 메서드에 로그 기능을 실행하는 코드가 삽입되어 있을 것이다. 만약 로그를 DB에 저장하지 않고 파일로 저장하는 경우, 우선 로그 기능이 삽입된 메서드를 찾고 삽입된 로그 코드를 적절하게 변경해야 한다.</p>
<p>이러한 방식은 산탄총 수술을 하는 것과 같이 변경될 곳을 빠짐없이 모두 찾아 수정해야 한다. 이를 해결하는 것이 부가 기능을 별개의 클래스로 분리해 책임을 담당하게 하는 것이다. 즉, 여러 곳에 흩어진 공통 책임을 한 곳에 모으면서 응집도를 높인다.</p>
<p>그러나 이런 독립 클래스를 구현하더라도 구현된 기능들을 호출하고 사용하는 코드는 해당 기능을 사용하는 코드 어딘가에 포함될 수 밖에 없다.</p>
<h3 id="관심지향-프로그래밍과-횡단-관심-문제"><a href="#관심지향-프로그래밍과-횡단-관심-문제" class="headerlink" title="관심지향 프로그래밍과 횡단 관심 문제"></a>관심지향 프로그래밍과 횡단 관심 문제</h3><p>횡단 관심 문제를 해결하는 방법으로 관심지향 프로그래밍(AOP, Aspect-Oriented Programming) 기법이 있다.</p>
<p>AOP는 횡단 관심을 수행하는 코드를 aspect라는 특별한 객체로 모듈화하고 weaving이라는 작업을 통해 모듈화된 코드를 핵심 기능에 끼워넣을 수 있다. 이를 통해 기존의 코드를 전혀 변경하지 않고도 시스템 핵심 기능에서 필요한 부가 기능을 효과적으로 이용할 수 있다. 만약 횡단 관심에 변경이 생긴다면 해당 aspect만 수정하면 된다.</p>
<p>*연관 관계의 역할 이름은 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있다.</p>
<p>SRP와 고전적 설계 개념인 응집도와 결합도의 관계는 다음과 같다.</p>
<p>응집도 - 한 프로그램 요소(절차지향 관점에서는 프로그램 함수나 프로시저, 객체지향적 관점에서는 클래스나 메서드)가 얼마나 뭉쳐 있는가를 나타내는 척도다. 가령 프로시저 하나가 단일 기능을 실행하도록 문장이나 자료구조가 구성되었다면 해당 기능을 실행하기 위해 해당 구성 요소 어떤 것도 빠뜨리지 못할 것이다. 말 그대로 구성 요소들 사이의 응집력이 강하다. 이에 반해 프로시저가 여러 기능을 실행하도록 구성되어 있다면 각각의 기능을 실행하는 데 필요한 구성 요소들 사이는 서로 별다른 연관이 없을 것이다. 이런 경우에 SRP를 따르면 응집도는 높아진다.</p>
<p>결합도 - 프로그램 구성 요소들 사이가 얼마나 의존적인지를 나타내는 척도. 프로그램 안 프로시저 하나의 자료구조가 다른 형태로 변경되었을 때 이 프로시저를 사요여하는 곳도 변경되어야 한다면 이 두 프로시저는 결합도가 높다. 그러나 아무런 영향을 미치지 않는다면 결합도는 낮다고 한다.</p>
<p>설계의 기본 원칙은 응집도는 높고, 결합도는 낮게 하는 것으로 세운다. 응집도가 높으면 관련 기능이 한 곳에 모여있게 되는데, 이는 재사용과 유지 보수가 쉬워진다. 결합도가 낮아야 하는 이유는 결합도가 높은 시스템의 한 부분이 변경이 되면 이에 연관된 부분들도 같이 변경하거나 회귀 테스트를 실행해야 한다. 더군다나 변경하려는 부분을 독립적으로 떼어놓기 어렵기 때문에 재사용성이 낮으며 이해하기도 쉽지 않다.</p>
<p>응집도와 결합도는 서로 독립적인 개념이 아니라 밀접한 관계가 있는 개념. 관련된 것들을 한 곳에 두어 응집도를 높이면 자연스럽게 결합도는 낮아진다. 따라서 한 클래스로 하여금 단일 책임을 갖게하는 SRP에 따른 설계를 하면 응집도는 높아지고 더불어 결합도는 낮아진다.</p>
<p>*AOP 관련 용어<br>조인포인트(Jointpoint) - 애플리케이션 실행 중의 특정한 지점을 의미. 전형적인 조인포인트의 예로는 메서드 호출, 메서드 실행 자체, 클래스 초기화, 객체 생성 시점 등이 있다. 조인포인트는 AOP의 핵심 개념이며 애플리케이션의 어떤 지점에서 AOP를 사용해 추가적인 로직을 삽입할지를 정의한다.</p>
<p>어드바이스(Advice) - 특정 조인포인트에 실행하는 코드. 조인포인트 이전에 실행하는 Before 어드바이스와 이후에 실행하는 After 어드바이스를 비롯한 여러 종류의 어드바이스가 있다.</p>
<p>포인트컷(Pointcit) - 여러 조인포인트의 집합체. 언제 어드바이스를 실행할지 정의할 때 사용. 포인트컷을 만들면 애플리케이션 구성 요소에 어드바이스를 어떻게 적용할지 상세하게 제어할 수 있다. 가장 일반적으로 사용하는 조인포인트는 메서드 호출. 따라서 가장 일반적인 포인트컷은 특정 클래스에 있는 모든 메서드 호출로 구성된다. 종종 어드바이스 실행 지점을 좀 더 다양하게 제어할 필요가 있을 때는 복잡한 형태로 포인트컷을 구성할 수도 있다.</p>
<p>애스펙트(Aspect) - 어드바이스와 포인트컷을 조합한 조합물. 즉, 애플리케이션이 가져야 할 로직과 그것을 실행해야 하는 지점을 정의한 것</p>
<p>위빙(Weaving) - 애플리케이션 코드의 해당 지점에 애스펙트를 실제로 주입하는 과정. 컴파일 시점 AOP 솔루션은 이 작업을 컴파일 시점에 하며 빌드 중에 별도의 과정을 거친다. 마찬가지로 실행 시점 AOP 솔루션은 실행 중에 동적으로 위빙이 일어난다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/26/2020-05-26-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/24/2020-05-24-1/"
                            aria-label=": SOLID - 의존성 역전 원칙(Dependency Inversion Principle)"
                        >
                            SOLID - 의존성 역전 원칙(Dependency Inversion Principle)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-24T23:09:23+09:00">
	
		    May 24, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Development/">Development</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="의존성-역전-원칙-Dependency-Inversion-Principle"><a href="#의존성-역전-원칙-Dependency-Inversion-Principle" class="headerlink" title="의존성 역전 원칙(Dependency Inversion Principle)"></a>의존성 역전 원칙(Dependency Inversion Principle)</h2><p>객체 사이에 서로 도움을 주고 받으면 의존 관계가 발생한다. 의존 역전 원칙 DIP는 이러한 관계를 맺을 때의 가이드라인에 해당한다.</p>
<p>DIP는 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것 보다는 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 원칙이다.</p>
<p>변하기 쉬운 것과 변하기 어려운 것은 정책, 전략과 같은 어떤 큰 흐름이나 개념 같은 추상적인 것은 변하기 어려운 것에 해당하고 구체적인 방식, 사물 등과 같은 것은 변하기 쉬운 것으로 구분하면 좋다.</p>
<p>객체지향의 관점에서는 변하기 어려운 추상적인 것들을 표현하는 수단으로 추상 클래스와 인터페이스가 있다.<br>DIP를 만족하려면 어떤 클래스가 도움을 받을 때 구체적인 클래스보다는 인터페이스나 추상 클래스와 의존 관계를 맺도록 설계해야 한다.<br>DIP를 만족하는 설계는 변화에 유연한 시스템이 된다.</p>
<p>인터페이스나 추상 클래스와 의존 관계를 맺도록 설계<br>인터페이스 = 변하지 않는 것<br>구체클래스 = 변하기 쉬운 것</p>
<p>DIP를 만족하면 의존성 주입(Dependency Injection)이라는 기술로 변화를 쉽게 수용할 수 있는 코드를 작성할 수 있다. 의존성 주입이란 말 그대로 클래스 외부에서 의존되는 것을 대상 객체에 인스턴스 변수에 주입하는 기술이다.<br>의존성 주입을 이용하면 대상 객체를 변경하지 않고도 외부에서 대상 객체의 외부 의존 객체를 바꿀 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Toy toy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToy</span><span class="params">(Toy toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toy = toy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toy.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kid 클래스에서 setToy 메서드로 아이가 가지고 노는 장난감을 바꿀 수 있다.<br>만약 로봇 장난감을 가지고 놀고 싶다면 다음 코드가 그 일을 해줄 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">extends</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Robot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Toy t = <span class="keyword">new</span> Robot();</span><br><span class="line">        Kid k = <span class="keyword">new</span> Kid();</span><br><span class="line">        k.setToy(t);</span><br><span class="line">        k.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>레고를 가지고 놀고 싶어진다면 다음 코드로 적용이 가능하다.<br>Kid, Toy, Robot 등 기존 코드에 영향을 받지 않고 장난감을 바꿀 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lego</span> <span class="keyword">extends</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Lego"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Toy t = <span class="keyword">new</span> Robot();</span><br><span class="line">        Kid k = <span class="keyword">new</span> Kid();</span><br><span class="line">        k.setToy(t);</span><br><span class="line">        k.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 Kid 클래스가 다음 클래스 다이어그램처럼 Robot 클래스와 연관 관계를 맺는다면 어떤 일이 발생할까</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Robot toy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToy</span><span class="params">(Robot toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toy = toy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toy.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Robot t = <span class="keyword">new</span> Robot();</span><br><span class="line">        Kid k = <span class="keyword">new</span> Kid();</span><br><span class="line">        k.setToy(t);</span><br><span class="line">        k.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이런 경우 레고로 장난감의 종류를 변경하려면 기존의 Kid 클래스가 다음처럼 바뀌어야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lego toy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//아이가 가지고 노는 장난감의 종류만큼 메서드가 존재해야 함.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToy</span><span class="params">(Lego toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toy = toy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toy.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>장난감을 바꿀 때마다 코드를 계속 바꿔야 한다. 즉 DIP의 위반이 OCP의 위반을 초래한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/24/2020-05-24-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/19/2020-05-19-2/"
                            aria-label=": 컴포넌트(Component)"
                        >
                            컴포넌트(Component)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-19T23:28:09+09:00">
	
		    May 19, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Software-Engineering/">Software Engineering</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>컴포넌트는 소프트웨어 시스템에서 독립적인 업무 또는 독립적인 기능을 수행하는 모듈로서 이후 시스템을 유지보수 하는데 있어 교체 가능한 부품이다.<br>소프트웨어 컴포넌트는 하드웨어의 그래픽카드와 같은 개념으로 독립적인 기능을 수행하는 소프트웨어 모듈이라고 말할 수 있으며 소프트웨어 컴포넌트는 컴포넌트란 말로 대체되어 사용되고 있다.</p>
<p>컴포넌트는 정의나 형태가 관점에 따라 다양하게 존재하지만 재사용 부품으로서의 컴포넌트가 되기 위해서는 아래의 내용을 만족해야 한다.<br>소스코드가 아닌 실행코드 기반으로 재사용할 수 있도록 이미 구현이 완료되어 있어야 한다.</p>
<p>컴포넌트는 용도, 유형, 기술표준과 인터페이스 등에 대한 정보들에 대해서 명세화가 되어 있어야 한다.<br>교체가능한 컴포넌트를 개발하기 위해서는 표준을 준수하여 개발해야 한다.<br>컴포넌트가 개발되어 배포될 때 관련 문서와 코드들이 독립적인 단위로 패키지화 되어 있어야 한다.<br>컴포넌트는 독립적인 업무 단위로 개발된 것이므로 사용자가 필요한 기능만을 패키지한 컴포넌트를 재사용할 수 있도록 독립적으로 배포 가능해야 한다.</p>
<p>컴포넌트, 클래스, 객체는 다른 개념으로 컴포넌트가 되기 위해서는 반드시 클래스나 객체로 만들어야 하는것은 아니다.<br>기존의 C나 Cobol로 개발된 모듈 또한 컴포넌트로 만들 수 있으나 현재의 컴포넌트 기술 표준들과 핵심개념들이 객체지향에서 비롯된 개념들이 많아 컴포넌트를 개발하는데 있어 객체지향 기술을 바탕으로 하는 것이 보다 효과적일 수 있다.<br>하나의 컴포넌트를 개발하기 위해서는 하나 이상의 클래스들을 바탕으로 개발할 수 있으며 이렇게 개발된 컴포넌트가 실행될 때 해당 컴포넌트의 인스턴스인 컴포넌트 객체가 수행된다.<br>이때 컴포넌트 내부에는 하나 이상의 클래스에 대응하는 하나 이상의 객체들이 수행되고 있는 것이라고 생각할 수 있다.</p>
<p>컴포넌트내의 정보는 외부로부터 은닉된다.<br>외부에서 접근할 수 있도록 컴포넌트가 제공하는 서비스를 정의한 인터페이스만을 제공하고 컴포넌트를 사용하기 위해서는 어떤 인터페이스를 사용해야 하는지만을 알 수 있다. 따라서 인터페이스는 외부와의 연결을 위해 반드시 존재해야만 하며 이처럼 컴포넌트가 내부 정보를 숨기고 인터페이스만을 제공함으로써 소프트웨어도 하드웨어처럼 조립 기반으로 갈 수 있게 된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/19/2020-05-19-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/19/2020-05-19-1/"
                            aria-label=": 소프트웨어 아키텍처 패턴 - 인터프리터 패턴(Interpreter Pattern)"
                        >
                            소프트웨어 아키텍처 패턴 - 인터프리터 패턴(Interpreter Pattern)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-19T00:30:48+09:00">
	
		    May 19, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Software-Engineering/">Software Engineering</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>인터프리터 패턴은 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용한다. 이는 주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다.</p>
<p>활용</p>
<ol>
<li>SQL과 같은 데이터베이스 쿼리 언어</li>
<li>통신 프로토콜을 정의하기 위한 언어</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/19/2020-05-19-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/19/2020-05-18-1/"
                            aria-label=": 소프트웨어 아키텍처 패턴 - 블랙보드 패턴(Blackboard Pattern)"
                        >
                            소프트웨어 아키텍처 패턴 - 블랙보드 패턴(Blackboard Pattern)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-19T00:09:25+09:00">
	
		    May 19, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Software-Engineering/">Software Engineering</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>블랙보드 패턴은 결정 가능한 해결 전략이 알려지지 않은 문제에 유용합니다. 블랙보드 패턴은 3가지 주요 컴포넌트로 구성됩니다. </p>
<ol>
<li>블랙보드(Blackboard) : 솔루션의 객체를 포함하는 구조화된 전역 메모리</li>
<li>자식소스(Knowledge Source) : 자체 표현을 가진 특수 모듈</li>
<li>제어 컴포넌트(Control Component) : 모듈 선택, 설정 및 실행을 담당</li>
</ol>
<p>모든 컴포넌트는 블랙보드에 접근하며 컴포넌트는 블랙보드에 추가되는 새로운 데이터 객체를 생성할 수 있다. 컴포넌트는 블랙보드에서 특정 종류의 데이터를 찾으며 기존의 지식 소스와의 패턴 매칭으로 데이터를 찾는다.</p>
<p>활용</p>
<ol>
<li>음성 인식</li>
<li>차량 식별 및 추적</li>
<li>단백질 구조 식별</li>
<li>수중 음파 탐지기 신호 해석</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/19/2020-05-18-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/17/2020-05-17-1/"
                            aria-label=": 소프트웨어 아키텍처 패턴 - 모델,뷰,컨트롤러 패턴(Model-View-Controller Pattern)"
                        >
                            소프트웨어 아키텍처 패턴 - 모델,뷰,컨트롤러 패턴(Model-View-Controller Pattern)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-17T19:56:18+09:00">
	
		    May 17, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Software-Engineering/">Software Engineering</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>모델, 뷰, 컨트롤러 패턴은 MVC패턴이라고도 한다. 대화형 애플리케이션을 다음의 3 부분으로 나눈다. </p>
<ol>
<li>모델(Model) - 핵심 기능과 데이터를 포함한다.</li>
<li>뷰(View) - 사용자에게 정보를 표시한다.</li>
<li>컨트롤러(Controller) - 사용자로부터의 입력을 처리한다.<br>사용자에게 정보가 제공되는 방식과 사용자로부터 받아 들여지는 방식에서 정보의 내부적인 표현을 분리하기 위해 나누어진다. 이는 컴포넌트를 분리하며 코드의 효율적인 재사용을 가능케한다.</li>
</ol>
<p>활용</p>
<ol>
<li>일반적인 웹 애플리케이션 설계 아키텍쳐</li>
<li>Django나 Rails와 같은 프레임워크</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/17/2020-05-17-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/16/2020-05-16-1/"
                            aria-label=": 소프트웨어 아키텍처 패턴 - 이벤트,버스 패턴(Event-Bus Pattern)"
                        >
                            소프트웨어 아키텍처 패턴 - 이벤트,버스 패턴(Event-Bus Pattern)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-16T23:17:01+09:00">
	
		    May 16, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Software-Engineering/">Software Engineering</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이벤트,버스 패턴은 주로 이벤트를 처리하며 이벤트 소스(event source), 이벤트 리스너(event listener), 채널(channel) 그리고 이벤트 버스(event bus)의 4가지 주요 컴포넌트들을 갖는다. 소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행(publish)하며 리스너는 특정 채널에서 메시지를 구독(subcribe)한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.</p>
<p>활용</p>
<ol>
<li>안드로이드 개발</li>
<li>알림 서비스</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/16/2020-05-16-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/page/2/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 5</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 sengwoolee. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/sengwoolee.png" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">sengwoolee</h4>
        
            <div id="about-card-bio"><p>Software Developer, Project Manager, Data Analyst, Quality Assurance</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Consalad Web Frontend/Backend Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Korea / Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
