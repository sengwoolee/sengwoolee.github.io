<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sengwoolee&#39;s development blog</title>
  
  <subtitle>sengwoolee&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sengwoolee.dev/"/>
  <updated>2020-05-18T15:24:56.915Z</updated>
  <id>https://sengwoolee.dev/</id>
  
  <author>
    <name>sengwoolee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 블랙보드 패턴(Blackboard Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/19/2020-05-18-1/"/>
    <id>https://sengwoolee.dev/2020/05/19/2020-05-18-1/</id>
    <published>2020-05-18T15:09:25.000Z</published>
    <updated>2020-05-18T15:24:56.915Z</updated>
    
    <content type="html"><![CDATA[<p>블랙보드 패턴은 결정 가능한 해결 전략이 알려지지 않은 문제에 유용합니다. 블랙보드 패턴은 3가지 주요 컴포넌트로 구성됩니다. </p><ol><li>블랙보드(Blackboard) : 솔루션의 객체를 포함하는 구조화된 전역 메모리</li><li>자식소스(Knowledge Source) : 자체 표현을 가진 특수 모듈</li><li>제어 컴포넌트(Control Component) : 모듈 선택, 설정 및 실행을 담당</li></ol><p>모든 컴포넌트는 블랙보드에 접근하며 컴포넌트는 블랙보드에 추가되는 새로운 데이터 객체를 생성할 수 있다. 컴포넌트는 블랙보드에서 특정 종류의 데이터를 찾으며 기존의 지식 소스와의 패턴 매칭으로 데이터를 찾는다.</p><p>활용</p><ol><li>음성 인식</li><li>차량 식별 및 추적</li><li>단백질 구조 식별</li><li>수중 음파 탐지기 신호 해석</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;블랙보드 패턴은 결정 가능한 해결 전략이 알려지지 않은 문제에 유용합니다. 블랙보드 패턴은 3가지 주요 컴포넌트로 구성됩니다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;블랙보드(Blackboard) : 솔루션의 객체를 포함하는 구조화된 전역 메모리&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 모델,뷰,컨트롤러 패턴(Model-View-Controller Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/17/2020-05-17-1/"/>
    <id>https://sengwoolee.dev/2020/05/17/2020-05-17-1/</id>
    <published>2020-05-17T10:56:18.000Z</published>
    <updated>2020-05-17T11:00:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>모델, 뷰, 컨트롤러 패턴은 MVC패턴이라고도 한다. 대화형 애플리케이션을 다음의 3 부분으로 나눈다. </p><ol><li>모델(Model) - 핵심 기능과 데이터를 포함한다.</li><li>뷰(View) - 사용자에게 정보를 표시한다.</li><li>컨트롤러(Controller) - 사용자로부터의 입력을 처리한다.<br>사용자에게 정보가 제공되는 방식과 사용자로부터 받아 들여지는 방식에서 정보의 내부적인 표현을 분리하기 위해 나누어진다. 이는 컴포넌트를 분리하며 코드의 효율적인 재사용을 가능케한다.</li></ol><p>활용</p><ol><li>일반적인 웹 애플리케이션 설계 아키텍쳐</li><li>Django나 Rails와 같은 프레임워크</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;모델, 뷰, 컨트롤러 패턴은 MVC패턴이라고도 한다. 대화형 애플리케이션을 다음의 3 부분으로 나눈다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;모델(Model) - 핵심 기능과 데이터를 포함한다.&lt;/li&gt;
&lt;li&gt;뷰(View) - 사용자에게 정보를 표시한다.&lt;
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 이벤트,버스 패턴(Event-Bus Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/16/2020-05-16-1/"/>
    <id>https://sengwoolee.dev/2020/05/16/2020-05-16-1/</id>
    <published>2020-05-16T14:17:01.000Z</published>
    <updated>2020-05-17T10:56:26.533Z</updated>
    
    <content type="html"><![CDATA[<p>이벤트,버스 패턴은 주로 이벤트를 처리하며 이벤트 소스(event source), 이벤트 리스너(event listener), 채널(channel) 그리고 이벤트 버스(event bus)의 4가지 주요 컴포넌트들을 갖는다. 소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행(publish)하며 리스너는 특정 채널에서 메시지를 구독(subcribe)한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.</p><p>활용</p><ol><li>안드로이드 개발</li><li>알림 서비스</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이벤트,버스 패턴은 주로 이벤트를 처리하며 이벤트 소스(event source), 이벤트 리스너(event listener), 채널(channel) 그리고 이벤트 버스(event bus)의 4가지 주요 컴포넌트들을 갖는다. 소스는 이벤트 버스를 
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 피어 투 피어 패턴(Peer-To-Peer Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/14/2020-05-14-1/"/>
    <id>https://sengwoolee.dev/2020/05/14/2020-05-14-1/</id>
    <published>2020-05-14T14:12:31.000Z</published>
    <updated>2020-05-17T10:56:31.600Z</updated>
    
    <content type="html"><![CDATA[<p>피어 투 피어 패턴은 각 컴포넌트를 피어로 부른다. 피어는 클라이언트로서 피어에게 서비스를 요청할 수도 있고 서버로서 각 피어에게 서비스를 제공할 수도 있다. 피어는 클라이언트 또는 서버 혹은 둘 모두로서 동작할 수 있으며 시간이 지남에 따라 역할이 유동적으로 바뀔 수 있다.</p><p>활용</p><ol><li>Gnutella나 G2와 같은 파일 공유 네트워크</li><li>P2PTV나 PDTP와 같은 멀티미디어 프로토콜</li><li>Spotify와 같은 독점적 멀티미디어 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;피어 투 피어 패턴은 각 컴포넌트를 피어로 부른다. 피어는 클라이언트로서 피어에게 서비스를 요청할 수도 있고 서버로서 각 피어에게 서비스를 제공할 수도 있다. 피어는 클라이언트 또는 서버 혹은 둘 모두로서 동작할 수 있으며 시간이 지남에 따라 역
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 브로커 패턴(Broker Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/11/2020-05-11-1/"/>
    <id>https://sengwoolee.dev/2020/05/11/2020-05-11-1/</id>
    <published>2020-05-11T13:52:26.000Z</published>
    <updated>2020-05-14T14:13:20.454Z</updated>
    
    <content type="html"><![CDATA[<p>브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호작용 할 수 있다. 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 한다.<br>서버는 자신의 기능들을 브로커에 넘겨주며 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리디렉션한다.</p><p>활용</p><ol><li>Apache ActiveMQ, Apache Kafka, RabbitMQ, JBoss Messaging - 메시지 브로커 소프트웨어</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호작용 할 수 있다. 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 한다.&lt;br&gt;서버는 자신의 기능들을 브로커에 넘겨주
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 파이프-필터 패턴(Pipe-Filter Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/10/2020-05-10-1/"/>
    <id>https://sengwoolee.dev/2020/05/10/2020-05-10-1/</id>
    <published>2020-05-10T07:37:04.000Z</published>
    <updated>2020-05-10T07:44:58.721Z</updated>
    
    <content type="html"><![CDATA[<p>파이프 필터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다. 각 처리 과정은 필터 컴포넌트에서 이루어지며 처리되는 데이터는 파이프를 통해 흐른다. 이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.</p><p>활용 </p><ol><li>컴파일러, 연속한 필터들은 어휘 분석, 파싱, 의미 분석, 코드 생성을 수행한다.</li><li>생물정보학에서의 워크플로우</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;파이프 필터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다. 각 처리 과정은 필터 컴포넌트에서 이루어지며 처리되는 데이터는 파이프를 통해 흐른다. 이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.&lt;/p&gt;
&lt;p&gt;활용 
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 마스터-슬레이브 패턴(Master-Slave Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/09/2020-05-09-1/"/>
    <id>https://sengwoolee.dev/2020/05/09/2020-05-09-1/</id>
    <published>2020-05-09T05:41:02.000Z</published>
    <updated>2020-05-09T05:58:10.771Z</updated>
    
    <content type="html"><![CDATA[<p>마스터-슬레이브 패턴은 마스터와 슬레이브 두 부분으로 구성된다. 마스터 컴포넌트는 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업을 분산하고 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.</p><p>활용</p><ol><li>데이터베이스 복제에서 마스터 데이터베이스는 신뢰할 수 있는 데이터 소스로 간주되며 슬레이브 데이터베이스는 마스터 데이터베이스와 동기화된다.</li><li>컴퓨터 시스템에서 버스와 연결된 주변장치 (마스터 드라이버와 슬레이브 드라이버)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;마스터-슬레이브 패턴은 마스터와 슬레이브 두 부분으로 구성된다. 마스터 컴포넌트는 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업을 분산하고 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.&lt;/p&gt;
&lt;p&gt;활용&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;데이터베
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 클라이언트-서버 패턴(Client-Server Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/06/2020-05-06-1/"/>
    <id>https://sengwoolee.dev/2020/05/06/2020-05-06-1/</id>
    <published>2020-05-06T14:33:02.000Z</published>
    <updated>2020-05-06T14:36:07.053Z</updated>
    
    <content type="html"><![CDATA[<p>클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에 적절한 서비스를 제공한다. 또한 서버는 계속 클라이언트로부터 요청을 대기한다.</p><p>활용</p><ol><li>이메일</li><li>문서 공유 및 은행 등의 온라인 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에 적절한 서비스를 제공한다. 또한 서버는 계속 클라이언트로
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 계층화 패턴(Layered Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/05/2020-05-05-2/"/>
    <id>https://sengwoolee.dev/2020/05/05/2020-05-05-2/</id>
    <published>2020-05-05T12:39:55.000Z</published>
    <updated>2020-05-05T12:44:58.700Z</updated>
    
    <content type="html"><![CDATA[<p>이 패턴은 n-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다. 각 하위 모듈들은 특정한 수준의 추상화를 제공한다. 각 계층은 다음 상위 계층에 서비스를 제공한다. </p><p>일반적인 정보 시스템에서 공통적으로 볼 수 있는 계층 4가지는 다음과 같다.</p><ol><li>프레젠테이션 계층(Presentation Layer) / UI 계층(UI Layer)</li><li>애플리케이션 계층(Application Layer) / 서비스 계층(Service Layer)</li><li>비즈니스 논리 계층(Business Logic Layer) / 도메인 계층(Domain Layer)</li><li>데이터 접근 계층(Data Access Layer) / 영속 계층 (Persistence Layer)</li></ol><p>활용</p><ol><li>일반적인 데스크톱 애플리케이션</li><li>E-Commerce 웹 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 패턴은 n-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다. 각 하위 모듈들은 특정한 수준의 추상화를 제공한다. 각 계층은 다음 상위 계층에 서비스를 제공한다. &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처</title>
    <link href="https://sengwoolee.dev/2020/05/05/2020-05-05-1/"/>
    <id>https://sengwoolee.dev/2020/05/05/2020-05-05-1/</id>
    <published>2020-05-05T12:32:23.000Z</published>
    <updated>2020-05-05T12:38:43.902Z</updated>
    
    <content type="html"><![CDATA[<p>SW 컴포넌트 사이의 상호관계를 설계하고 정의한 시스템 구조이다.</p><h3 id="소프트웨어-아키텍처의-특징"><a href="#소프트웨어-아키텍처의-특징" class="headerlink" title="소프트웨어 아키텍처의 특징"></a>소프트웨어 아키텍처의 특징</h3><ol><li>간략성<br> 이해하고 추론할 수 있을 정도의 간결성을 유지</li><li>추상화<br> 시스템의 추상적인 표현을 사용</li><li>가시성<br> 시스템이 포함해야 하는 것들을 가시화</li></ol><h3 id="소프트웨어-아키텍처-구성요소"><a href="#소프트웨어-아키텍처-구성요소" class="headerlink" title="소프트웨어 아키텍처 구성요소"></a>소프트웨어 아키텍처 구성요소</h3><ol><li>Architecture Description(AD)<br> 아키텍처를 기록하기 위한 산출물을 의미한다.<br> 하나의 AD는 System의 하나 이상의 View로 구성되어 있다.</li><li>이해관계자<br> 소프트웨어 시스템 개발에 관련된 모든 사람과 조직을 의미하며 고객 개발자 프로젝트 관리자 등을 포함한다.</li><li>관심사<br> 동일한 시스템에 대해 서로 다른 이해관계자의 의견이다.</li><li>관점<br> 서로 다른 역할이나 책임으로 시스템이나 산출물에 대한 서로 다른 관점이다.</li><li>뷰<br> 이해 관계자들가 이들이 가지는 생각이나 견해로부터 전체 시스템을 표현한다.<br> (4 + 1 View)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SW 컴포넌트 사이의 상호관계를 설계하고 정의한 시스템 구조이다.&lt;/p&gt;
&lt;h3 id=&quot;소프트웨어-아키텍처의-특징&quot;&gt;&lt;a href=&quot;#소프트웨어-아키텍처의-특징&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어 아키텍처의 특징&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7 Apache SSL인증서 적용 (Certbot, Let&#39;s encrypt)</title>
    <link href="https://sengwoolee.dev/2020/05/02/2020-05-04-1/"/>
    <id>https://sengwoolee.dev/2020/05/02/2020-05-04-1/</id>
    <published>2020-05-02T08:37:29.000Z</published>
    <updated>2020-05-05T12:22:47.588Z</updated>
    
    <content type="html"><![CDATA[<p>환경 : CentOS7 / Apache</p><p>EPEL 저장소 활성화 및 apache용 certbot 설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install certbot python2-certbot-apache</span><br></pre></td></tr></table></figure><p>certbot에서 apache를 기반으로 자동구성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache</span><br></pre></td></tr></table></figure><p>certbot에서 apache를 수동으로 구성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache certonly</span><br></pre></td></tr></table></figure><p>certbot을 설정하여 구성 완료 후 문제가 없을 경우 아래 메시지가 출력된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">/etc/letsencrypt/live/sengwoolee.dev/fullchain.pem</span><br><span class="line">Your key file has been saved at:</span><br><span class="line">/etc/letsencrypt/live/sengwoolee.dev/privkey.pem</span><br></pre></td></tr></table></figure><p>apache 서비스 재시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure><p>certbot 인증서 자동 갱신 테스트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --dry-run</span><br></pre></td></tr></table></figure><p>자동갱신 추가</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>아래 내용 작성 후 저장<br>0       0,12    *       *       *       python -c ‘import random; import time; time.sleep(random.random() * 3600)’ &amp;&amp; certbot renew</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;환경 : CentOS7 / Apache&lt;/p&gt;
&lt;p&gt;EPEL 저장소 활성화 및 apache용 certbot 설치&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu Errors were encountered while processing 해결</title>
    <link href="https://sengwoolee.dev/2020/05/01/2020-05-01-1/"/>
    <id>https://sengwoolee.dev/2020/05/01/2020-05-01-1/</id>
    <published>2020-05-01T14:11:49.000Z</published>
    <updated>2020-05-01T14:13:59.615Z</updated>
    
    <content type="html"><![CDATA[<p>dpkg 기록 삭제</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/dpkg/info/*</span><br></pre></td></tr></table></figure><p>dpkg 재설정</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --configure<span class="_">-a</span></span><br></pre></td></tr></table></figure><p>업데이트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dpkg 기록 삭제&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>IaaS, PaaS, SaaS</title>
    <link href="https://sengwoolee.dev/2020/04/28/2020-04-28-1/"/>
    <id>https://sengwoolee.dev/2020/04/28/2020-04-28-1/</id>
    <published>2020-04-28T14:29:33.000Z</published>
    <updated>2020-05-01T14:01:23.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS(Infrastructure as a Service)"></a>IaaS(Infrastructure as a Service)</h2><p>서버를 운영하기 위해서 필요한 서버 자원, IP, 네트워크, 스토리지, 전력 등등 을 가상의 환경에서 쉽고 편하게 사용할 수 있도록 서비스 형태로 제공한다. 기존 서버 호스팅보다 하드웨어 확장성이 좋고 탄력적이며 빠른 제공을 할 수 있는 가상화 기술을 이용한다. Pass와 Saas의 기반이 된다.</p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS(Platform as a Service)"></a>PaaS(Platform as a Service)</h2><p>IaaS를 기본으로 개발툴과 기능, 애플리케이션 배포 등 개발환경에 부가적인 서비스를 안전하게 제공하는 것이다. 미들웨어와 데이터베이스 관리, 애널리틱스 혹은 운영체제 등이 포함된다. 개발자가 애플리케이션을 개발하고 배포하는데 필요한 모든 것들을 제공해야 한다. PaaS를 이용하면 개발자는 기반 인프라스트럭처를 프로비저닝할 필요가 없다.</p><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS(Software as a Service)"></a>SaaS(Software as a Service)</h2><p>서드파티가 호스팅 방식으로 소프트웨어를 제공하는 것이다. 사용자는 내부 구성을 관리할 필요가 없다. 이메일이나 CRM 소프트웨어 등에서 널리 사용된다.<br>머신 혹은 서버를 기준으로 소프트웨어 라이선스를 구매해 직접 사용하던 기존의 구매 방식과 차별화된 서비스를 제공한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IaaS-Infrastructure-as-a-Service&quot;&gt;&lt;a href=&quot;#IaaS-Infrastructure-as-a-Service&quot; class=&quot;headerlink&quot; title=&quot;IaaS(Infrastructure as a Ser
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>데이터베이스 정규화, 반정규화</title>
    <link href="https://sengwoolee.dev/2020/04/26/2020-04-26-1/"/>
    <id>https://sengwoolee.dev/2020/04/26/2020-04-26-1/</id>
    <published>2020-04-26T11:09:57.000Z</published>
    <updated>2020-04-27T13:56:22.535Z</updated>
    
    <content type="html"><![CDATA[<p>데이터베이스의 정규화, 반정규화에 대해 작성한다.</p><ol><li>정규화(Normalization)<br>정규화는 데이터의 중복성을 제거하여 여러 엔티티의 조인이 발생하는 데이터베이스 환경에서 성능을 향상시키기 위한 데이터 구조화 프로세스를 말한다.</li></ol><p>정규화 단계<br>-제1정규화<br>중복되는 컬럼을 제거한다.<br>-제2정규화<br>종속되는 값을 제거한다.<br>-제3정규화<br>엔티티에 맞는 데이터로 분리한다.</p><ol start="2"><li>반정규화(역정규화, Denormalization)<br>정규화로 인해 테이블 수가 증가하면 다수의 조인이 발생함에 따라 성능 저하가 발생할 수 있다.<br>이 문제를 해결하고자 정규화 과정이 모두 마무리된 다음 반정규화를 실시한다.<br>단 테이벌을 합치는 것만이 반정규화는 아니다.</li></ol><p>-그룹에 대한 합계 값을 미리 계산하여 테이블에 저장<br>(기존 테이블에 sum 하는것이 아니라 별도의 통계 테이블을 생성)<br>-하나의 테이블에서 자주 사용되는 레코드와 그렇지 않은 행들을 분리<br>-자주 조인하여 사용하는 컬럼을 중복제거하여 하나의 테이블로 생성</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;데이터베이스의 정규화, 반정규화에 대해 작성한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;정규화(Normalization)&lt;br&gt;정규화는 데이터의 중복성을 제거하여 여러 엔티티의 조인이 발생하는 데이터베이스 환경에서 성능을 향상시키기 위한 데이터 구조화 프로세스
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>boilerplate</title>
    <link href="https://sengwoolee.dev/2020/04/25/2020-04-25-2/"/>
    <id>https://sengwoolee.dev/2020/04/25/2020-04-25-2/</id>
    <published>2020-04-25T13:30:20.000Z</published>
    <updated>2020-04-25T13:35:02.728Z</updated>
    
    <content type="html"><![CDATA[<p>보일러플레이트(boilerplate)는 변경 없이 재사용할 수 있는 저작품을 의미하며,<br>프로그래밍에서는 상용구 코드를 의미한다.<br>어떤 동작을 수행하기 위해 사전에 작성해야 하는 코드로서<br>자바에서는 클래스의 getter, setter 메소드를 말한다.</p><p>보일러 플레이트의 특징은 다음과 같다.</p><ol><li>최소한의 변경으로 재사용할 수 있는것</li><li>적은 수정만으로 여러 곳에 활용이 가능한 코드, 문구</li><li>각종 문서에서 반복적으로 인용되는 문서의 한 부분</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;보일러플레이트(boilerplate)는 변경 없이 재사용할 수 있는 저작품을 의미하며,&lt;br&gt;프로그래밍에서는 상용구 코드를 의미한다.&lt;br&gt;어떤 동작을 수행하기 위해 사전에 작성해야 하는 코드로서&lt;br&gt;자바에서는 클래스의 getter, sette
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>프레임워크 Express, Koa, Hapi</title>
    <link href="https://sengwoolee.dev/2020/04/25/2020-04-25-1/"/>
    <id>https://sengwoolee.dev/2020/04/25/2020-04-25-1/</id>
    <published>2020-04-25T13:15:16.000Z</published>
    <updated>2020-04-25T13:29:02.299Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Express<br>Node.js 프레임워크 중 커뮤니티가 가장 크다.<br>StrongLoop에 의해 관리되고 있다.<br>내장 라우터로 코드를 쉽게 재사용할 수 있다.</li></ol><p>내장된 에러 핸들링이 없다.<br>다른 프레임워크에 비해 메모리를 많이 차지한다.</p><ol start="2"><li>Koa<br>다른 프레임워크에 비해 미들웨어 작성이 쉽다.<br>기본적으로 뼈대 프레임워크라서 개발자가 필요한 미들웨어만 구성해 사용할 수 있다.<br>ES6 제너레이터를 사용할 수 있다.</li></ol><p>아직 불안정하며 많은 개발이 진행중이다.<br>미들웨어를 직접 작성할 수 있는게 장점이자 단점이다.</p><ol start="3"><li>Hapi<br>코드보다 설정을 더 많이 해야 한다.<br>견고함과 재사용성을 요구하는 큰 규모 팀에서 흔하게 사용된다.<br>월마트랩에서 만들고 이름있는 회사에서 많이 쓰고 있어서 검증되었다고 보는 편이다.</li></ol><p>크고 복잡한 어플리케이션에 특화되어 있다.<br>보일러플레이트로 작성해야 할 코드가 많아서 작은 웹앱에서 쓰기는 불편하고 예제 및 hapi로 작성된 오픈소스 앱도 적다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Express&lt;br&gt;Node.js 프레임워크 중 커뮤니티가 가장 크다.&lt;br&gt;StrongLoop에 의해 관리되고 있다.&lt;br&gt;내장 라우터로 코드를 쉽게 재사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;내장된 에러 핸들링이 없다.&lt;br&gt;다른
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://sengwoolee.dev/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>컴퓨터 아키텍쳐, 소프트웨어 아키텍쳐</title>
    <link href="https://sengwoolee.dev/2020/04/22/2020-04-22-1/"/>
    <id>https://sengwoolee.dev/2020/04/22/2020-04-22-1/</id>
    <published>2020-04-22T14:15:53.000Z</published>
    <updated>2020-04-22T14:43:34.573Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터 아키텍쳐는 컴퓨터 구조로서 컴퓨터 공학의 개념의 살계이며 컴퓨터 시스템의 근간이 되는 운영 구조이다. 컴퓨터의 설계적으로 이식되는 것들과 요구 사항들(특히 속도와 상호 연결)이 무엇인지 기능적으로 설명되어 있는 청사진이다. 주로 중앙처리장치가 메모리 주소에 내부적으로 수행하고 접근하는 방법이 집중적으로 설명된다.</p><p>소프트웨어 아키텍쳐는 소프트웨어 구조로서 소프트웨어의 구성요소들 사이에서 유기적인 관계를 표현하고 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙을 말한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;컴퓨터 아키텍쳐는 컴퓨터 구조로서 컴퓨터 공학의 개념의 살계이며 컴퓨터 시스템의 근간이 되는 운영 구조이다. 컴퓨터의 설계적으로 이식되는 것들과 요구 사항들(특히 속도와 상호 연결)이 무엇인지 기능적으로 설명되어 있는 청사진이다. 주로 중앙처리장
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>Index</title>
    <link href="https://sengwoolee.dev/2020/04/20/2020-04-20-1/"/>
    <id>https://sengwoolee.dev/2020/04/20/2020-04-20-1/</id>
    <published>2020-04-20T14:18:34.000Z</published>
    <updated>2020-04-20T15:26:18.738Z</updated>
    
    <content type="html"><![CDATA[<p>Index는 테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체이다.<br>대부분 B-Tress, B+Tree 구조를 가진다.<br>Index는 논리적/물리적으로 테이블과 독립적이다.</p><p>테이블의 레코드는 순서 없이 저장되는데 인덱스가 없는 테이블의 데이터를 찾을 때 무조건 풀스캔을 한다. 데이터의 양이 많을 경우 풀스캔을 하게되면 처리 성능이 떨어진다. 인덱스를 통해 데이터를 빨리 찾고자 사용한다.</p><p>인덱스를 생성할 때는 WHERE 절과 JOIN, ORDER BY 등 키 값의 선별이 가능한 컬럼에 생성한다. 테이블이 자주 갱신될 경우엔 인덱스를 사용하지 않는 것이 좋다.</p><p>인덱스는 클러스터드 인덱스와 논클러스터드 인덱스로 나누어진다. 클러스터드 인덱스는 물리적인 정렬로 데이터를 입력 시 이것을 기준으로 입력된다. 테이블에 하나만 존재할 수 있으며 테이블을 열었을 때 ORDER BY 를 사용하지 않아도 데이터가 클러스터드 인덱싱이 되어있는 것을 확인할 수 있다. 논클러스터드 인덱스는 중복된 값을 가지면 한 테이블에 여러개를 생성할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Index는 테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체이다.&lt;br&gt;대부분 B-Tress, B+Tree 구조를 가진다.&lt;br&gt;Index는 논리적/물리적으로 테이블과 독립적이다.&lt;/p&gt;
&lt;p&gt;테이블의 레코드는 순서 없이 저장되는
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL - GROUP BY, HAVING </title>
    <link href="https://sengwoolee.dev/2020/04/19/2020-04-19-1/"/>
    <id>https://sengwoolee.dev/2020/04/19/2020-04-19-1/</id>
    <published>2020-04-19T14:39:52.000Z</published>
    <updated>2020-04-19T14:50:13.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>데이터를 원하는 그룹으로 나누어 가져온다.<br>그룹의 컬럼명을 GROUP BY 절 뒤에 추가해 사용한다.<br>집계함수와 함께 사용되는 상수는 GROUP BY 절에 추가하지 않아도 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TEST_NAME, TEST_TEXT, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TEST_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(*) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>WHERE 절에서는 집계함수 사용이 불가능하다.<br>집계함수를 가지고 조건비교를 할 때 HAVING 을 사용한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TEST_NAME, TEST_TEXT, <span class="keyword">COUNT</span>(TEST_NO)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TEST_NAME</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(TEST_NO) &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GROUP-BY&quot;&gt;&lt;a href=&quot;#GROUP-BY&quot; class=&quot;headerlink&quot; title=&quot;GROUP BY&quot;&gt;&lt;/a&gt;GROUP BY&lt;/h2&gt;&lt;p&gt;데이터를 원하는 그룹으로 나누어 가져온다.&lt;br&gt;그룹의 컬럼명을 GROUP BY 절
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL 튜닝</title>
    <link href="https://sengwoolee.dev/2020/04/18/2020-04-18-1/"/>
    <id>https://sengwoolee.dev/2020/04/18/2020-04-18-1/</id>
    <published>2020-04-18T14:16:10.000Z</published>
    <updated>2020-04-18T14:33:17.135Z</updated>
    
    <content type="html"><![CDATA[<p>같은 결과의 쿼리는 여러 형태로 작성될 수 있으며 옵티마이저가 실행계획을 생성할 때 최대 성능의 쿼리를 작성해야 한다.</p><p>옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다.</p><p>사용자가 구조화된 질의언어로 결과집합을 요구하면 이를 생성하는데 필요한 처리경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해주며 이 처리 경로를 실행계획이라고 부른다.</p><p>더 높은 성능의 쿼리를 작성하기 위한 튜닝 가이드라인을 작성한다.</p><ol><li>WHERE 조건에 인덱스 모두 사용<br>TEST 테이블에서 TEST_NO, TEST_CONTEXT 컬럼이 TEST_NO_IDX 인덱스로 존재할 때 아래 쿼리는 인덱스를 사용하지 않는다.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">WHERE</span> TEST_COTEXT = <span class="string">'OPTION'</span></span><br></pre></td></tr></table></figure><p>아래와 같이 사용하면 인덱스를 사용하게 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">WHERE</span> TEST_NO = <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> TEST_CONTEXT = <span class="string">'OPTION'</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>LIKE 보다는 = 를 사용<br>LIKE 등의 연산자는 인덱스 효율이 떨어진다.<br>IS NULL, IS NOT NULL, NOT IN 등의 경우에도 인덱스 효율이 떨어진다.</p></li><li><p>인덱스 컬럼은 변형하지 않고 사용<br>SUBSTR등으로 인덱스 컬럼의 값을 변경하면 FULL SCAN을 하게된다.</p></li><li><p>AND를 사용<br>옵티마이저의 OR-Expansion 처리는 OR 연산자의 쿼리를 UNION ALL로 변환하여 쿼리의 성능이 저하된다.</p></li><li><p>HAVING 보다 WHERE 을 사용<br>그룹핑 쿼리 처리 순서상 WHERE 이 먼저 처리되므로 필터링 대상은 WHERE 조건에서 처리할 수 있또록 작성해야 한다.</p></li><li><p>DISTINCT 사용 지양<br>키워드 내부적으로 정렬 작업을 진행하므로 꼭 필요한 경우가 아니면 사용을 지양한다.</p></li><li><p>EXISTS, NOT EXISTS를 사용<br>IN, NOT IN 연산자보다 EXISTS나 NOT EXISTS를 사용하는 것이 더 좋은 성능을 발휘한다.</p></li><li><p>SET 연산자 사용시 UNION ALL 사용<br>UNION 연산자는 동일한 로우를 제거하고 한 로우만 반환한다.<br>필터링 로직이 숨어 있어 UNION ALL 보다 실행 비용이 높다.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;같은 결과의 쿼리는 여러 형태로 작성될 수 있으며 옵티마이저가 실행계획을 생성할 때 최대 성능의 쿼리를 작성해야 한다.&lt;/p&gt;
&lt;p&gt;옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다.&lt;
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
</feed>
