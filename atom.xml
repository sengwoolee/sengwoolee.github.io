<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sengwoolee&#39;s development blog</title>
  
  <subtitle>sengwoolee&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sengwoolee.dev/"/>
  <updated>2020-05-06T14:36:07.053Z</updated>
  <id>https://sengwoolee.dev/</id>
  
  <author>
    <name>sengwoolee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 클라이언트-서버 패턴(Client-Server Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/06/2020-05-06-1/"/>
    <id>https://sengwoolee.dev/2020/05/06/2020-05-06-1/</id>
    <published>2020-05-06T14:33:02.000Z</published>
    <updated>2020-05-06T14:36:07.053Z</updated>
    
    <content type="html"><![CDATA[<p>클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에 적절한 서비스를 제공한다. 또한 서버는 계속 클라이언트로부터 요청을 대기한다.</p><p>활용</p><ol><li>이메일</li><li>문서 공유 및 은행 등의 온라인 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에 적절한 서비스를 제공한다. 또한 서버는 계속 클라이언트로
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 계층화 패턴(Layered Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/05/2020-05-05-2/"/>
    <id>https://sengwoolee.dev/2020/05/05/2020-05-05-2/</id>
    <published>2020-05-05T12:39:55.000Z</published>
    <updated>2020-05-05T12:44:58.700Z</updated>
    
    <content type="html"><![CDATA[<p>이 패턴은 n-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다. 각 하위 모듈들은 특정한 수준의 추상화를 제공한다. 각 계층은 다음 상위 계층에 서비스를 제공한다. </p><p>일반적인 정보 시스템에서 공통적으로 볼 수 있는 계층 4가지는 다음과 같다.</p><ol><li>프레젠테이션 계층(Presentation Layer) / UI 계층(UI Layer)</li><li>애플리케이션 계층(Application Layer) / 서비스 계층(Service Layer)</li><li>비즈니스 논리 계층(Business Logic Layer) / 도메인 계층(Domain Layer)</li><li>데이터 접근 계층(Data Access Layer) / 영속 계층 (Persistence Layer)</li></ol><p>활용</p><ol><li>일반적인 데스크톱 애플리케이션</li><li>E-Commerce 웹 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 패턴은 n-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다. 각 하위 모듈들은 특정한 수준의 추상화를 제공한다. 각 계층은 다음 상위 계층에 서비스를 제공한다. &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처</title>
    <link href="https://sengwoolee.dev/2020/05/05/2020-05-05-1/"/>
    <id>https://sengwoolee.dev/2020/05/05/2020-05-05-1/</id>
    <published>2020-05-05T12:32:23.000Z</published>
    <updated>2020-05-05T12:38:43.902Z</updated>
    
    <content type="html"><![CDATA[<p>SW 컴포넌트 사이의 상호관계를 설계하고 정의한 시스템 구조이다.</p><h3 id="소프트웨어-아키텍처의-특징"><a href="#소프트웨어-아키텍처의-특징" class="headerlink" title="소프트웨어 아키텍처의 특징"></a>소프트웨어 아키텍처의 특징</h3><ol><li>간략성<br> 이해하고 추론할 수 있을 정도의 간결성을 유지</li><li>추상화<br> 시스템의 추상적인 표현을 사용</li><li>가시성<br> 시스템이 포함해야 하는 것들을 가시화</li></ol><h3 id="소프트웨어-아키텍처-구성요소"><a href="#소프트웨어-아키텍처-구성요소" class="headerlink" title="소프트웨어 아키텍처 구성요소"></a>소프트웨어 아키텍처 구성요소</h3><ol><li>Architecture Description(AD)<br> 아키텍처를 기록하기 위한 산출물을 의미한다.<br> 하나의 AD는 System의 하나 이상의 View로 구성되어 있다.</li><li>이해관계자<br> 소프트웨어 시스템 개발에 관련된 모든 사람과 조직을 의미하며 고객 개발자 프로젝트 관리자 등을 포함한다.</li><li>관심사<br> 동일한 시스템에 대해 서로 다른 이해관계자의 의견이다.</li><li>관점<br> 서로 다른 역할이나 책임으로 시스템이나 산출물에 대한 서로 다른 관점이다.</li><li>뷰<br> 이해 관계자들가 이들이 가지는 생각이나 견해로부터 전체 시스템을 표현한다.<br> (4 + 1 View)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SW 컴포넌트 사이의 상호관계를 설계하고 정의한 시스템 구조이다.&lt;/p&gt;
&lt;h3 id=&quot;소프트웨어-아키텍처의-특징&quot;&gt;&lt;a href=&quot;#소프트웨어-아키텍처의-특징&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어 아키텍처의 특징&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7 Apache SSL인증서 적용 (Certbot, Let&#39;s encrypt)</title>
    <link href="https://sengwoolee.dev/2020/05/02/2020-05-04-1/"/>
    <id>https://sengwoolee.dev/2020/05/02/2020-05-04-1/</id>
    <published>2020-05-02T08:37:29.000Z</published>
    <updated>2020-05-05T12:22:47.588Z</updated>
    
    <content type="html"><![CDATA[<p>환경 : CentOS7 / Apache</p><p>EPEL 저장소 활성화 및 apache용 certbot 설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install certbot python2-certbot-apache</span><br></pre></td></tr></table></figure><p>certbot에서 apache를 기반으로 자동구성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache</span><br></pre></td></tr></table></figure><p>certbot에서 apache를 수동으로 구성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache certonly</span><br></pre></td></tr></table></figure><p>certbot을 설정하여 구성 완료 후 문제가 없을 경우 아래 메시지가 출력된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">/etc/letsencrypt/live/sengwoolee.dev/fullchain.pem</span><br><span class="line">Your key file has been saved at:</span><br><span class="line">/etc/letsencrypt/live/sengwoolee.dev/privkey.pem</span><br></pre></td></tr></table></figure><p>apache 서비스 재시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure><p>certbot 인증서 자동 갱신 테스트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --dry-run</span><br></pre></td></tr></table></figure><p>자동갱신 추가</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>아래 내용 작성 후 저장<br>0       0,12    *       *       *       python -c ‘import random; import time; time.sleep(random.random() * 3600)’ &amp;&amp; certbot renew</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;환경 : CentOS7 / Apache&lt;/p&gt;
&lt;p&gt;EPEL 저장소 활성화 및 apache용 certbot 설치&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu Errors were encountered while processing 해결</title>
    <link href="https://sengwoolee.dev/2020/05/01/2020-05-01-1/"/>
    <id>https://sengwoolee.dev/2020/05/01/2020-05-01-1/</id>
    <published>2020-05-01T14:11:49.000Z</published>
    <updated>2020-05-01T14:13:59.615Z</updated>
    
    <content type="html"><![CDATA[<p>dpkg 기록 삭제</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/dpkg/info/*</span><br></pre></td></tr></table></figure><p>dpkg 재설정</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --configure<span class="_">-a</span></span><br></pre></td></tr></table></figure><p>업데이트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dpkg 기록 삭제&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>IaaS, PaaS, SaaS</title>
    <link href="https://sengwoolee.dev/2020/04/28/2020-04-28-1/"/>
    <id>https://sengwoolee.dev/2020/04/28/2020-04-28-1/</id>
    <published>2020-04-28T14:29:33.000Z</published>
    <updated>2020-05-01T14:01:23.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS(Infrastructure as a Service)"></a>IaaS(Infrastructure as a Service)</h2><p>서버를 운영하기 위해서 필요한 서버 자원, IP, 네트워크, 스토리지, 전력 등등 을 가상의 환경에서 쉽고 편하게 사용할 수 있도록 서비스 형태로 제공한다. 기존 서버 호스팅보다 하드웨어 확장성이 좋고 탄력적이며 빠른 제공을 할 수 있는 가상화 기술을 이용한다. Pass와 Saas의 기반이 된다.</p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS(Platform as a Service)"></a>PaaS(Platform as a Service)</h2><p>IaaS를 기본으로 개발툴과 기능, 애플리케이션 배포 등 개발환경에 부가적인 서비스를 안전하게 제공하는 것이다. 미들웨어와 데이터베이스 관리, 애널리틱스 혹은 운영체제 등이 포함된다. 개발자가 애플리케이션을 개발하고 배포하는데 필요한 모든 것들을 제공해야 한다. PaaS를 이용하면 개발자는 기반 인프라스트럭처를 프로비저닝할 필요가 없다.</p><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS(Software as a Service)"></a>SaaS(Software as a Service)</h2><p>서드파티가 호스팅 방식으로 소프트웨어를 제공하는 것이다. 사용자는 내부 구성을 관리할 필요가 없다. 이메일이나 CRM 소프트웨어 등에서 널리 사용된다.<br>머신 혹은 서버를 기준으로 소프트웨어 라이선스를 구매해 직접 사용하던 기존의 구매 방식과 차별화된 서비스를 제공한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IaaS-Infrastructure-as-a-Service&quot;&gt;&lt;a href=&quot;#IaaS-Infrastructure-as-a-Service&quot; class=&quot;headerlink&quot; title=&quot;IaaS(Infrastructure as a Ser
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>데이터베이스 정규화, 반정규화</title>
    <link href="https://sengwoolee.dev/2020/04/26/2020-04-26-1/"/>
    <id>https://sengwoolee.dev/2020/04/26/2020-04-26-1/</id>
    <published>2020-04-26T11:09:57.000Z</published>
    <updated>2020-04-27T13:56:22.535Z</updated>
    
    <content type="html"><![CDATA[<p>데이터베이스의 정규화, 반정규화에 대해 작성한다.</p><ol><li>정규화(Normalization)<br>정규화는 데이터의 중복성을 제거하여 여러 엔티티의 조인이 발생하는 데이터베이스 환경에서 성능을 향상시키기 위한 데이터 구조화 프로세스를 말한다.</li></ol><p>정규화 단계<br>-제1정규화<br>중복되는 컬럼을 제거한다.<br>-제2정규화<br>종속되는 값을 제거한다.<br>-제3정규화<br>엔티티에 맞는 데이터로 분리한다.</p><ol start="2"><li>반정규화(역정규화, Denormalization)<br>정규화로 인해 테이블 수가 증가하면 다수의 조인이 발생함에 따라 성능 저하가 발생할 수 있다.<br>이 문제를 해결하고자 정규화 과정이 모두 마무리된 다음 반정규화를 실시한다.<br>단 테이벌을 합치는 것만이 반정규화는 아니다.</li></ol><p>-그룹에 대한 합계 값을 미리 계산하여 테이블에 저장<br>(기존 테이블에 sum 하는것이 아니라 별도의 통계 테이블을 생성)<br>-하나의 테이블에서 자주 사용되는 레코드와 그렇지 않은 행들을 분리<br>-자주 조인하여 사용하는 컬럼을 중복제거하여 하나의 테이블로 생성</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;데이터베이스의 정규화, 반정규화에 대해 작성한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;정규화(Normalization)&lt;br&gt;정규화는 데이터의 중복성을 제거하여 여러 엔티티의 조인이 발생하는 데이터베이스 환경에서 성능을 향상시키기 위한 데이터 구조화 프로세스
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>boilerplate</title>
    <link href="https://sengwoolee.dev/2020/04/25/2020-04-25-2/"/>
    <id>https://sengwoolee.dev/2020/04/25/2020-04-25-2/</id>
    <published>2020-04-25T13:30:20.000Z</published>
    <updated>2020-04-25T13:35:02.728Z</updated>
    
    <content type="html"><![CDATA[<p>보일러플레이트(boilerplate)는 변경 없이 재사용할 수 있는 저작품을 의미하며,<br>프로그래밍에서는 상용구 코드를 의미한다.<br>어떤 동작을 수행하기 위해 사전에 작성해야 하는 코드로서<br>자바에서는 클래스의 getter, setter 메소드를 말한다.</p><p>보일러 플레이트의 특징은 다음과 같다.</p><ol><li>최소한의 변경으로 재사용할 수 있는것</li><li>적은 수정만으로 여러 곳에 활용이 가능한 코드, 문구</li><li>각종 문서에서 반복적으로 인용되는 문서의 한 부분</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;보일러플레이트(boilerplate)는 변경 없이 재사용할 수 있는 저작품을 의미하며,&lt;br&gt;프로그래밍에서는 상용구 코드를 의미한다.&lt;br&gt;어떤 동작을 수행하기 위해 사전에 작성해야 하는 코드로서&lt;br&gt;자바에서는 클래스의 getter, sette
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>프레임워크 Express, Koa, Hapi</title>
    <link href="https://sengwoolee.dev/2020/04/25/2020-04-25-1/"/>
    <id>https://sengwoolee.dev/2020/04/25/2020-04-25-1/</id>
    <published>2020-04-25T13:15:16.000Z</published>
    <updated>2020-04-25T13:29:02.299Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Express<br>Node.js 프레임워크 중 커뮤니티가 가장 크다.<br>StrongLoop에 의해 관리되고 있다.<br>내장 라우터로 코드를 쉽게 재사용할 수 있다.</li></ol><p>내장된 에러 핸들링이 없다.<br>다른 프레임워크에 비해 메모리를 많이 차지한다.</p><ol start="2"><li>Koa<br>다른 프레임워크에 비해 미들웨어 작성이 쉽다.<br>기본적으로 뼈대 프레임워크라서 개발자가 필요한 미들웨어만 구성해 사용할 수 있다.<br>ES6 제너레이터를 사용할 수 있다.</li></ol><p>아직 불안정하며 많은 개발이 진행중이다.<br>미들웨어를 직접 작성할 수 있는게 장점이자 단점이다.</p><ol start="3"><li>Hapi<br>코드보다 설정을 더 많이 해야 한다.<br>견고함과 재사용성을 요구하는 큰 규모 팀에서 흔하게 사용된다.<br>월마트랩에서 만들고 이름있는 회사에서 많이 쓰고 있어서 검증되었다고 보는 편이다.</li></ol><p>크고 복잡한 어플리케이션에 특화되어 있다.<br>보일러플레이트로 작성해야 할 코드가 많아서 작은 웹앱에서 쓰기는 불편하고 예제 및 hapi로 작성된 오픈소스 앱도 적다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Express&lt;br&gt;Node.js 프레임워크 중 커뮤니티가 가장 크다.&lt;br&gt;StrongLoop에 의해 관리되고 있다.&lt;br&gt;내장 라우터로 코드를 쉽게 재사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;내장된 에러 핸들링이 없다.&lt;br&gt;다른
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://sengwoolee.dev/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>컴퓨터 아키텍쳐, 소프트웨어 아키텍쳐</title>
    <link href="https://sengwoolee.dev/2020/04/22/2020-04-22-1/"/>
    <id>https://sengwoolee.dev/2020/04/22/2020-04-22-1/</id>
    <published>2020-04-22T14:15:53.000Z</published>
    <updated>2020-04-22T14:43:34.573Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터 아키텍쳐는 컴퓨터 구조로서 컴퓨터 공학의 개념의 살계이며 컴퓨터 시스템의 근간이 되는 운영 구조이다. 컴퓨터의 설계적으로 이식되는 것들과 요구 사항들(특히 속도와 상호 연결)이 무엇인지 기능적으로 설명되어 있는 청사진이다. 주로 중앙처리장치가 메모리 주소에 내부적으로 수행하고 접근하는 방법이 집중적으로 설명된다.</p><p>소프트웨어 아키텍쳐는 소프트웨어 구조로서 소프트웨어의 구성요소들 사이에서 유기적인 관계를 표현하고 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙을 말한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;컴퓨터 아키텍쳐는 컴퓨터 구조로서 컴퓨터 공학의 개념의 살계이며 컴퓨터 시스템의 근간이 되는 운영 구조이다. 컴퓨터의 설계적으로 이식되는 것들과 요구 사항들(특히 속도와 상호 연결)이 무엇인지 기능적으로 설명되어 있는 청사진이다. 주로 중앙처리장
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>Index</title>
    <link href="https://sengwoolee.dev/2020/04/20/2020-04-20-1/"/>
    <id>https://sengwoolee.dev/2020/04/20/2020-04-20-1/</id>
    <published>2020-04-20T14:18:34.000Z</published>
    <updated>2020-04-20T15:26:18.738Z</updated>
    
    <content type="html"><![CDATA[<p>Index는 테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체이다.<br>대부분 B-Tress, B+Tree 구조를 가진다.<br>Index는 논리적/물리적으로 테이블과 독립적이다.</p><p>테이블의 레코드는 순서 없이 저장되는데 인덱스가 없는 테이블의 데이터를 찾을 때 무조건 풀스캔을 한다. 데이터의 양이 많을 경우 풀스캔을 하게되면 처리 성능이 떨어진다. 인덱스를 통해 데이터를 빨리 찾고자 사용한다.</p><p>인덱스를 생성할 때는 WHERE 절과 JOIN, ORDER BY 등 키 값의 선별이 가능한 컬럼에 생성한다. 테이블이 자주 갱신될 경우엔 인덱스를 사용하지 않는 것이 좋다.</p><p>인덱스는 클러스터드 인덱스와 논클러스터드 인덱스로 나누어진다. 클러스터드 인덱스는 물리적인 정렬로 데이터를 입력 시 이것을 기준으로 입력된다. 테이블에 하나만 존재할 수 있으며 테이블을 열었을 때 ORDER BY 를 사용하지 않아도 데이터가 클러스터드 인덱싱이 되어있는 것을 확인할 수 있다. 논클러스터드 인덱스는 중복된 값을 가지면 한 테이블에 여러개를 생성할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Index는 테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체이다.&lt;br&gt;대부분 B-Tress, B+Tree 구조를 가진다.&lt;br&gt;Index는 논리적/물리적으로 테이블과 독립적이다.&lt;/p&gt;
&lt;p&gt;테이블의 레코드는 순서 없이 저장되는
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL - GROUP BY, HAVING </title>
    <link href="https://sengwoolee.dev/2020/04/19/2020-04-19-1/"/>
    <id>https://sengwoolee.dev/2020/04/19/2020-04-19-1/</id>
    <published>2020-04-19T14:39:52.000Z</published>
    <updated>2020-04-19T14:50:13.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>데이터를 원하는 그룹으로 나누어 가져온다.<br>그룹의 컬럼명을 GROUP BY 절 뒤에 추가해 사용한다.<br>집계함수와 함께 사용되는 상수는 GROUP BY 절에 추가하지 않아도 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TEST_NAME, TEST_TEXT, <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TEST_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(*) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>WHERE 절에서는 집계함수 사용이 불가능하다.<br>집계함수를 가지고 조건비교를 할 때 HAVING 을 사용한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TEST_NAME, TEST_TEXT, <span class="keyword">COUNT</span>(TEST_NO)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TEST_NAME</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(TEST_NO) &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GROUP-BY&quot;&gt;&lt;a href=&quot;#GROUP-BY&quot; class=&quot;headerlink&quot; title=&quot;GROUP BY&quot;&gt;&lt;/a&gt;GROUP BY&lt;/h2&gt;&lt;p&gt;데이터를 원하는 그룹으로 나누어 가져온다.&lt;br&gt;그룹의 컬럼명을 GROUP BY 절
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL 튜닝</title>
    <link href="https://sengwoolee.dev/2020/04/18/2020-04-18-1/"/>
    <id>https://sengwoolee.dev/2020/04/18/2020-04-18-1/</id>
    <published>2020-04-18T14:16:10.000Z</published>
    <updated>2020-04-18T14:33:17.135Z</updated>
    
    <content type="html"><![CDATA[<p>같은 결과의 쿼리는 여러 형태로 작성될 수 있으며 옵티마이저가 실행계획을 생성할 때 최대 성능의 쿼리를 작성해야 한다.</p><p>옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다.</p><p>사용자가 구조화된 질의언어로 결과집합을 요구하면 이를 생성하는데 필요한 처리경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해주며 이 처리 경로를 실행계획이라고 부른다.</p><p>더 높은 성능의 쿼리를 작성하기 위한 튜닝 가이드라인을 작성한다.</p><ol><li>WHERE 조건에 인덱스 모두 사용<br>TEST 테이블에서 TEST_NO, TEST_CONTEXT 컬럼이 TEST_NO_IDX 인덱스로 존재할 때 아래 쿼리는 인덱스를 사용하지 않는다.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">WHERE</span> TEST_COTEXT = <span class="string">'OPTION'</span></span><br></pre></td></tr></table></figure><p>아래와 같이 사용하면 인덱스를 사용하게 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TEST</span></span><br><span class="line"><span class="keyword">WHERE</span> TEST_NO = <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> TEST_CONTEXT = <span class="string">'OPTION'</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>LIKE 보다는 = 를 사용<br>LIKE 등의 연산자는 인덱스 효율이 떨어진다.<br>IS NULL, IS NOT NULL, NOT IN 등의 경우에도 인덱스 효율이 떨어진다.</p></li><li><p>인덱스 컬럼은 변형하지 않고 사용<br>SUBSTR등으로 인덱스 컬럼의 값을 변경하면 FULL SCAN을 하게된다.</p></li><li><p>AND를 사용<br>옵티마이저의 OR-Expansion 처리는 OR 연산자의 쿼리를 UNION ALL로 변환하여 쿼리의 성능이 저하된다.</p></li><li><p>HAVING 보다 WHERE 을 사용<br>그룹핑 쿼리 처리 순서상 WHERE 이 먼저 처리되므로 필터링 대상은 WHERE 조건에서 처리할 수 있또록 작성해야 한다.</p></li><li><p>DISTINCT 사용 지양<br>키워드 내부적으로 정렬 작업을 진행하므로 꼭 필요한 경우가 아니면 사용을 지양한다.</p></li><li><p>EXISTS, NOT EXISTS를 사용<br>IN, NOT IN 연산자보다 EXISTS나 NOT EXISTS를 사용하는 것이 더 좋은 성능을 발휘한다.</p></li><li><p>SET 연산자 사용시 UNION ALL 사용<br>UNION 연산자는 동일한 로우를 제거하고 한 로우만 반환한다.<br>필터링 로직이 숨어 있어 UNION ALL 보다 실행 비용이 높다.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;같은 결과의 쿼리는 여러 형태로 작성될 수 있으며 옵티마이저가 실행계획을 생성할 때 최대 성능의 쿼리를 작성해야 한다.&lt;/p&gt;
&lt;p&gt;옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다.&lt;
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>저장 프로시저(Stored Procedure)</title>
    <link href="https://sengwoolee.dev/2020/04/16/2020-04-16-1/"/>
    <id>https://sengwoolee.dev/2020/04/16/2020-04-16-1/</id>
    <published>2020-04-16T14:03:38.000Z</published>
    <updated>2020-04-16T14:18:03.991Z</updated>
    
    <content type="html"><![CDATA[<p>저장 프로시저(Stored Procedure)는 SQL 서버에서 제공되는 프로그래밍 기능이다.<br>쿼리문의 집합으로 동작을 일괄 처리하는 용도이다.</p><p>정의</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transact-SQL Stored Procedure Syntax</span></span><br><span class="line"><span class="keyword">CREATE</span> &#123; PROC | <span class="keyword">PROCEDURE</span> &#125; [schema_name.] procedure_name [ ; number ] </span><br><span class="line">    [ &#123; @parameter [ type_schema_name. ] data_type &#125; </span><br><span class="line">        [ VARYING ] [ = default ] [ OUT | OUTPUT ] [READONLY]</span><br><span class="line">    ] [ ,...n ] </span><br><span class="line">[ <span class="keyword">WITH</span> &lt;procedure_option&gt; [ ,...n ] ]</span><br><span class="line">[ <span class="keyword">FOR</span> <span class="keyword">REPLICATION</span> ] </span><br><span class="line"><span class="keyword">AS</span> &#123; [ <span class="keyword">BEGIN</span> ] sql_statement [;] [ ...n ] [ <span class="keyword">END</span> ] &#125;</span><br><span class="line">[;]</span><br><span class="line"> </span><br><span class="line">&lt;procedure_option&gt; ::= </span><br><span class="line">    [ ENCRYPTION ]</span><br><span class="line">    [ RECOMPILE ]</span><br><span class="line">    [ <span class="keyword">EXECUTE</span> <span class="keyword">AS</span> Clause ]</span><br></pre></td></tr></table></figure><p>수정<br>ALTER PROCEDURE<br>삭제<br>DROP PROCEDURE</p><p>저장된 프로시저 확인</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.name, m.definition</span><br><span class="line"><span class="keyword">FROM</span> sys.sql_modules <span class="keyword">AS</span> m</span><br><span class="line"><span class="keyword">JOIN</span> sys.objects <span class="keyword">AS</span> o</span><br><span class="line"><span class="keyword">ON</span> m.object_id = o.object_id <span class="keyword">AND</span> o.type = <span class="string">'P'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> sp_helptext usp_error;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저장 프로시저(Stored Procedure)는 SQL 서버에서 제공되는 프로그래밍 기능이다.&lt;br&gt;쿼리문의 집합으로 동작을 일괄 처리하는 용도이다.&lt;/p&gt;
&lt;p&gt;정의&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>트랜잭션</title>
    <link href="https://sengwoolee.dev/2020/04/15/2020-04-15-1/"/>
    <id>https://sengwoolee.dev/2020/04/15/2020-04-15-1/</id>
    <published>2020-04-15T14:14:46.000Z</published>
    <updated>2020-04-15T14:24:20.645Z</updated>
    
    <content type="html"><![CDATA[<p>트랜잭션(Transaction)은 하나의 논리적 작업 단위로 수행되는 일련의 작업을 말한다.</p><p>트랜잭션은 데이터 일치성과 동시발생을 보장하기 위해 사용한다.<br>트랜잭션 작업 시 영향을 받은 행들은 락처리 되며<br>다른 사용자는 해당 행을 변경할 수 없다.</p><p>트랜잭션 작업 후 커밋시 영향받았던 행들에 대해 락이 해제되며<br>트랜잭션이 완료 처리된다.</p><p>트랜잭션 롤백 시 트랜잭션 생성 이전 시점으로 롤백된다.</p><p>롤백 세그먼트(Rollback Segment)<br>롤백 세그먼트는 수정되기 전의 파일, 블록 ID 등 블럭 정보 및 데이터를 저장한다.</p><p>MSSQL의 경우 BEGIN TRAN 으로 트랜잭션을 시작하고<br>트랜잭션 성공시 COMMIT 하거나 ROLLBACK 할 수 있다.</p><p>트랜잭션이 성공하면 트랜잭션 동안 이루어진 일련의 작업 결과는 커밋되고 데이터베이스의 영구적으로 반영된다.</p><p>트랜잭션에 오류가 발생하여 취소되거나 롤백되면 일련의 작업 내역은 모두 취소된다.</p><p>MSSQL은 기본적으로 자동 커밋을 한다.<br>트랜잭션은 트랜잭션 로그 파일 *.ldf에 저장된다.<br>커밋하면 실제 데이터 파일인 *.mdf에 적용된다.</p><p>커밋/롤백 전까지 데이터에는 락이 걸린다.<br>락 상태에서 select 시도 시 잠금이 발생하여 쿼리가 지연된다.</p><p>BEGIN TRY/END TRY … BEGIN CATCH/END CATCH 등으로<br>TRY-CATCH 와 COMMIT/ROLLBACT 을 같이 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;트랜잭션(Transaction)은 하나의 논리적 작업 단위로 수행되는 일련의 작업을 말한다.&lt;/p&gt;
&lt;p&gt;트랜잭션은 데이터 일치성과 동시발생을 보장하기 위해 사용한다.&lt;br&gt;트랜잭션 작업 시 영향을 받은 행들은 락처리 되며&lt;br&gt;다른 사용자는 해
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>2. Node.js 서버 띄우기</title>
    <link href="https://sengwoolee.dev/2020/04/13/2020-04-13-1/"/>
    <id>https://sengwoolee.dev/2020/04/13/2020-04-13-1/</id>
    <published>2020-04-13T14:29:18.000Z</published>
    <updated>2020-04-13T14:49:11.508Z</updated>
    
    <content type="html"><![CDATA[<p>node.js 로 서버를 구동하기 위해 express를 사용한다.<br>작업할 폴더에서 터미널을 실행 후 다음 명령어를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>npm은 node.js package manager의 약자로 node.js의 패키지 관리 프로그램이다.</p><p>추가로 ejs를 설치한다.<br>ejs는 embeded javascript의 약자로 변수를 꺼내어 사용하는 html 탬플릿이다.<br>html 코드 내에 javascript를 사용할 수 있도록 해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs</span><br></pre></td></tr></table></figure><p>작업 폴더 내에 views 폴더를 만들고 view 로 render 할 ejs 파일을 넣어준다.<br>test.ejs를 생성하고 다음과 같이 작성한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;TEST RENDER PAGE&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;TEST TEST TEST&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>작업 폴더 루트에 app.js 파일을 생성하고 다음과 같이 작성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>) <span class="comment">// express 모듈 로드</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">"ejs"</span>) <span class="comment">// ejs 모듈 로드</span></span><br><span class="line"><span class="keyword">const</span> app = express() <span class="comment">// app을 express로 로드</span></span><br><span class="line"></span><br><span class="line">app.set(<span class="string">"view engine"</span>, <span class="string">"ejs"</span>);</span><br><span class="line">app.use(express_static(__dirname +<span class="string">'/'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test"</span>) <span class="comment">// console 출력</span></span><br><span class="line">    res.render(<span class="string">"test"</span>, &#123;&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"localhost:3000 실행중"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>프로젝트 루트 폴더에서 다음 명령어로 서버를 구동한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>localhost:3000 에서 실행된 서버를 확인한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;node.js 로 서버를 구동하기 위해 express를 사용한다.&lt;br&gt;작업할 폴더에서 터미널을 실행 후 다음 명령어를 입력한다.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://sengwoolee.dev/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>데이터베이스</title>
    <link href="https://sengwoolee.dev/2020/04/12/2020-04-12-2/"/>
    <id>https://sengwoolee.dev/2020/04/12/2020-04-12-2/</id>
    <published>2020-04-12T13:54:16.000Z</published>
    <updated>2020-04-12T14:06:16.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="정보시스템"><a href="#정보시스템" class="headerlink" title="정보시스템"></a>정보시스템</h1><p>데이터를 통해 정보를 얻어내는 시스템을 말한다.<br>현실세계에서 데이터를 수집하고 데이터를 처리하여 유의미한 정보를 얻어내는 시스템이다.</p><p>데이터 : 현실 세계의 단순한 관찰을 통해 수집된 사실 또는 값<br>정보 : 특정 해석이나 의미를 갖는 데이터</p><h1 id="데이터베이스-시스템"><a href="#데이터베이스-시스템" class="headerlink" title="데이터베이스 시스템"></a>데이터베이스 시스템</h1><p>데이터를 처리하여 정보를 얻어내는 과정을 도와주는 시스템이다.<br>데이터베이스의 특징은 다음과 같다.</p><ol><li>실시간 접근성</li><li>계속적인 변화</li><li>동시 공유성</li><li>운영 가능</li><li>내용 참조</li></ol><h1 id="DBMS-Database-Management-System"><a href="#DBMS-Database-Management-System" class="headerlink" title="DBMS(Database Management System)"></a>DBMS(Database Management System)</h1><p>데이터베이스를 다루기 위한 시스템을 의미한다.<br>데이터를 정의,조작,제어할 수 있으며 관계형 데이터베이스 관리 시스템에서는 SQL 사용이 가능하다.</p><p>DDL(Data Manipulation Language) : 데이터 정의어<br>DML(Data Definition Language) : 데이터 조작어<br>DCL(Data Control Language) : 데이터 제어어<br>TCL(Transaction Control Language) : 트랜잭션 제어어</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;정보시스템&quot;&gt;&lt;a href=&quot;#정보시스템&quot; class=&quot;headerlink&quot; title=&quot;정보시스템&quot;&gt;&lt;/a&gt;정보시스템&lt;/h1&gt;&lt;p&gt;데이터를 통해 정보를 얻어내는 시스템을 말한다.&lt;br&gt;현실세계에서 데이터를 수집하고 데이터를 처리하여 유
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>1. Node.js 소개 및 설치</title>
    <link href="https://sengwoolee.dev/2020/04/12/2020-04-12-1/"/>
    <id>https://sengwoolee.dev/2020/04/12/2020-04-12-1/</id>
    <published>2020-04-12T13:34:31.000Z</published>
    <updated>2020-04-12T13:51:17.452Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js는 Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경으로 주로 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어 플랫폼이다. </p><p>Node.js는 자바스크립트를 사용해 개발한다. Front-end와 Back-end에서 자바스크립트를 사용할 수 있다는 동형성은 별도의 언어 학습 시간을 단축해주는 장점이 있다.</p><p>Node.js는 Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 Request 처리 성능을 가지고 있다. 데이터베이스로부터 대량의 데이터를 취득하여 웹페이지에 표시할 때, 일반적으로 데이터베이스 처리에 대기시간이 발생하기 때문에 웹페이지 표시가 지연되는 현상이 발생한다. Node.js의 모든 API는 비동기 방식으로 동작하여 Non-blocking I/O가 가능하고 단일 스레드 이벤트 루프 모델을 사용하여 보다 가벼운 환경에서도 높은 Request 처리 성능을 가지고 있다.</p><p>Node.js는 데이터를 실시간 처리하여 빈번한 I/O가 발생하는 SPA(Single Page Application)에 적합하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.</p><p>현재 해당 블로그도 Node.js 기반의 Hexo 로 개발되어 있다.</p><p>Node.js를 사용하기 위해 다음 사이트에서 설치를 진행한다.<br>(<a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org</a>)</p><p>LTS와 Current버전을 제공하는데 LTS는 Long Term Supported 버전으로 장기적으로 안정적인 지원이 보장되는 버전이다. Current버전은 최신 버전으로 안정적이지 않을 수 있다. 필자는 LTS버전을 사용한다.</p><p>사용하는 운영체제에 적합한 버전을 설치하면 npm 도 함께 설치된다.</p><p>설치가 완료 되었다면 node -v, npm -v를 통해 정상적으로 설치되었는지 확인한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Node.js는 Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경으로 주로 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어 플랫폼이다. &lt;/p&gt;
&lt;p&gt;Node.js는 자바스크립트를 사용해 개발한다. Front-end와 B
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://sengwoolee.dev/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>기능 테스트, 비기능 테스트, 구조적 테스트</title>
    <link href="https://sengwoolee.dev/2020/04/09/2020-04-09-1/"/>
    <id>https://sengwoolee.dev/2020/04/09/2020-04-09-1/</id>
    <published>2020-04-09T14:35:56.000Z</published>
    <updated>2020-04-09T15:03:55.034Z</updated>
    
    <content type="html"><![CDATA[<p>기능 테스트와 비기능 테스트에 대해 작성한다.</p><h1 id="1-기능-테스트-Functional-Test"><a href="#1-기능-테스트-Functional-Test" class="headerlink" title="1. 기능 테스트 (Functional Test)"></a>1. 기능 테스트 (Functional Test)</h1><p>기능 테스트는 고객의 기능적 요구사항을 중점적으로 테스트 하는것이다.<br>요구사항에 따른 기능의 구현 여부 및 동작 여부에 대해 테스트를 진행한다.<br>테스트 기준은 명세에 따르며 명세를 기반으로 테스트 조건과 테스트 케이스를 도출한다.</p><p>[기능 테스트 분류]</p><ul><li>단위 테스트</li><li>통합 테스트</li><li>인수 테스트</li><li>회귀 테스트 등</li></ul><h1 id="2-비기능-테스트-Non-Functional-Test"><a href="#2-비기능-테스트-Non-Functional-Test" class="headerlink" title="2. 비기능 테스트 (Non-Functional Test)"></a>2. 비기능 테스트 (Non-Functional Test)</h1><p>비기능 테스트는 고객의 성능적 요구사항을 중점적으로 테스트하는 것이다.<br>비기능적인 측면인 성능, 신뢰성, 안정성, 유요성, 적합성 등을 확인한다.<br>비기능 테스트는 확인하고자 하는 특성에 따라 환경 구성과 관련 도구가 필요할 수 있다.</p><p>[비기능 테스트 분류]</p><ul><li>볼륨 테스트</li><li>확장성 테스트 </li><li>사용성 테스트 </li><li>성능 테스트 등</li></ul><h1 id="3-구조적-테스트-Software-Structure-Architecture-Test"><a href="#3-구조적-테스트-Software-Structure-Architecture-Test" class="headerlink" title="3. 구조적 테스트 (Software Structure/Architecture Test)"></a>3. 구조적 테스트 (Software Structure/Architecture Test)</h1><p>구조적 테스트는 화이트 박스 테스트라고도 하며 소프트웨어가 어떻게 구성되었는지 테스트하는 것이다.<br>테스트 커버리지를 평가하여 보장성과 충분함을 측정한다.<br>커버리지는 테스트 스위트에 의해 테스트된 정도를 의미하며 퍼센트 형식으로 표시한다.</p><p>[화이트 박스 테스트 분류]</p><ul><li>구문 테스트</li><li>결정 테스트</li><li>조건 테스트</li><li>데이터 흐름 테스트 등</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;기능 테스트와 비기능 테스트에 대해 작성한다.&lt;/p&gt;
&lt;h1 id=&quot;1-기능-테스트-Functional-Test&quot;&gt;&lt;a href=&quot;#1-기능-테스트-Functional-Test&quot; class=&quot;headerlink&quot; title=&quot;1. 기능 테스트 (
      
    
    </summary>
    
    
      <category term="QA" scheme="https://sengwoolee.dev/categories/QA/"/>
    
    
  </entry>
  
  <entry>
    <title>CI(Continuous Integration)/CD(Continuous Deploy/Delivery)</title>
    <link href="https://sengwoolee.dev/2020/04/07/2020-04-07-1/"/>
    <id>https://sengwoolee.dev/2020/04/07/2020-04-07-1/</id>
    <published>2020-04-07T14:43:31.000Z</published>
    <updated>2020-04-07T14:59:24.103Z</updated>
    
    <content type="html"><![CDATA[<p>CI(Continuous Integration)/CD(Continuous Deploy/Delivery) 의 개념에 대해 작성한다.</p><h1 id="CI-Continuous-Integration"><a href="#CI-Continuous-Integration" class="headerlink" title="CI(Continuous Integration)"></a>CI(Continuous Integration)</h1><p>CI는 지속적 통합(Continuous Integration)으로 코드를 지속적으로 통합하는 것이다.<br>전통적인 방식의 개발은 여러명의 개발자가 협업을 진행할때 각자가 중앙저장소에 통합하는 프로세스로 개발을 진행하다.<br>하지만 컴포넌트, 피쳐의 개발이 완료될 때까지 프로젝트에 참여한 모든 개발자가 중앙저장소에 코드를 통합하지 않았다면 통합과정은 매우 어렵고 힘든 일이 될 것이다.</p><p>이런 문제를 해결하고자 지속적 통합(CI)이 등장했다.<br>CI를 자동화 하지 않은 상태에서 수행하면 개발자는 중앙저장소에 코드를 통합하고, 본인의 코드를 중앙저장소에서 테스트하고, 중앙저장소의 빌드를 테스트를 하는 복잡한 절차를 거쳐 CI를 진행해야 한다.</p><p>자동화된 CI는 개발자는 작업한 코드를 중앙 저장소에 통합하면 테스트와 빌드 등의 복잡한 절차를 자동적으로 처리해준다.<br>따라서 CI와 자동화는 밀접한 관계를 맺고 있다.</p><h1 id="CD-Continuous-Deploy-Delivery"><a href="#CD-Continuous-Deploy-Delivery" class="headerlink" title="CD(Continuous Deploy/Delivery)"></a>CD(Continuous Deploy/Delivery)</h1><p>CD는 지속적 배포(Continuous Deploy/Delivery)으로 지속적으로 소프트웨어가 신뢰 가능한 수준으로 배포될 수 있도록 관리하는 것이다.</p><p>CD를 진행하기 위해서는 CI의 진행이 필수적이다.<br>CI를 진행하며 개발 과정에서 지속적으로 빌드와 테스트를 진행하고,<br>테스트를 통과한 신뢰 가능한 코드에 대해서 테스트 서버와 운영 서버에 바로 배포 및 반영하는 것이다.</p><p>자동화된 CI, CD환경이 구축되면 개발 과정에서 빌드 및 테스트가 자동으로 진행되고 테스트 서버와 운영 서버에 배포되는 과정까지 자동화되는 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CI(Continuous Integration)/CD(Continuous Deploy/Delivery) 의 개념에 대해 작성한다.&lt;/p&gt;
&lt;h1 id=&quot;CI-Continuous-Integration&quot;&gt;&lt;a href=&quot;#CI-Continuous-I
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
</feed>
