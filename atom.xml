<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sengwoolee&#39;s development blog</title>
  
  <subtitle>sengwoolee&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sengwoolee.dev/"/>
  <updated>2020-05-26T14:38:33.277Z</updated>
  <id>https://sengwoolee.dev/</id>
  
  <author>
    <name>sengwoolee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SOLID - 단일 책임 원칙(Single Responsibility Principle)</title>
    <link href="https://sengwoolee.dev/2020/05/26/2020-05-26-1/"/>
    <id>https://sengwoolee.dev/2020/05/26/2020-05-26-1/</id>
    <published>2020-05-26T14:19:34.000Z</published>
    <updated>2020-05-26T14:38:33.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="단일-책임-원칙-Single-Responsibility-Principle"><a href="#단일-책임-원칙-Single-Responsibility-Principle" class="headerlink" title="단일 책임 원칙(Single Responsibility Principle)"></a>단일 책임 원칙(Single Responsibility Principle)</h3><p>객체는 단 하나의 책임만을 가져야 한다. 책임이란 객체가 할수 있는 것, 해야 하는 것을 말한다.</p><p>예를들어 학생 클래스가 수강 과목을 추가하거나 조회하고 데이터베이스에 객체 정보를 저장하거나 데이터베이스에서 객체 정보를 읽는 작업도 처리하고 성적표와 출석부를 출력하는 일도 한다고 가정했을 때 이런 경우 학생 클래스의 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCourses</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCourses</span><span class="params">(Course c)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">load</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOnReportCard</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOnAttendanceBook</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재 코드의 경우 Student 클래스는 너무 많은 책임을 수행해야 한다. 이는 곧 변경될 여지가 많다는 것이다. 현재 Student 클래스는 할당된 책임 중 가장 잘할 수 있는 것은 수강 과목을 추가하고 조회하는 일이다.</p><p>DB에 학생 정보를 저장하고 DB로부터 읽는 일이나 성적표와 출석부에 출력하는 일은 Student 클래스가 아닌 다른 클래스가 더 잘할 수 있는 여지가 많다. 따라서 Student 클래스에는 수강 과목을 추가하고 조회하는 책임을 수행하도록 하는 것이 SRP를 따르는 설계다.</p><p>설계 원칙을 학습하는 이유는 예측못한 변경사항에 유연하고 확장성 있도록 시스템 구조를 설계하기 위함이다. 즉 가능한 한 영향을 받는 부분을 줄여야 한다. 어떤 클래스가 잘 설계되었는지를 판단하려면 언제 변경되어야 하는지를 묻는것이 좋다.</p><p>현재의 Student 클래스가 언제 변경되어야 하는지를 알아보려면 변경 이유를 찾아보는 것이 좋다.</p><ul><li>DB의 스키마가 변경된다면 Student 클래스도 변경되어야 하는가?</li><li>학생이 지도 교수를 찾는 기능이 추가되어야 한다면 Student 클래스는 영향을 받는가?</li><li>학생 정보를 성적표와 출석부 이외의 형식으로 출력해야 한다면 어떻게 해야 하는가?</li></ul><p>3가지 모두 Student 클래스를 변경해야 하는 이유가 된다.</p><p>또한 책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합된 가능성이 높아진다.</p><p>예를 들어 현재 수강 과목을 조회하는 코드(getCourse 메서드)와 DB에서 학생 정보를 가져오는 코드(load 메서드) 중 어딘가가 연결될 수도 있고, 학생이 수강 과목을 추가하는 코드(addCourse 메서드)와 DB에 학생 정보를 갱신하는 코드(save 메서드)가 서로 연결될 수도 있다.</p><p>이런 경우 DB 스키마의 변화가 학생의 고유한 기능(getCourses 메서드, addCourse 메서드)을 구현한 코드에 변화를 필요하게 할 수도 있다.</p><h3 id="책임-분리"><a href="#책임-분리" class="headerlink" title="책임 분리"></a>책임 분리</h3><p>Student 클래스는 여러 책임을 수행하므로 Student 클래스의 도움을 필요로 하는 코드도 많을 수 밖에 없다.</p><p>학생의 수강 과목 목록을 사용해 어떤 일을 수행하는 코드도 Student 클래스의 도움을 필요로 하며, 신입생 정보를 DB에 기록하는 데도 Student 클래스를 필요로 할 수 있다. 또한 성적표와 출석부를 필요로 하는 코드도 Student 클래스를 사용할 수 있다.</p><p>이런 이유 때문에 Student 클래스에 변경사항이 생기면 Student 클래스를 사용하는 코드와 전혀 관계가 없더라도 직접 또는 간접적으로 사용하는 모든 코드를 다시 테스트해야 한다. </p><p>성적표에 학생을 표시하는 기능에 변경사항이 생기면 수강 과목을 조회하거나 등록하는 기능을 사용하는 코드도 다시 테스트해야 한다는 의미다. 이와 같이 어떤 변화가 있을 때 해당 변화가 기존 시스템의 기능에 영향을 주는지 평가하는 테스트를 회귀테스트라 한다.</p><p>모든 코드를 테스트하는 문제를 해결하려면 한 클래스에서 단 하나의 책임만 수행하도록 해 변경 사유가 될 수 있는 것을 하나로 만들어야 한다. 이를 책임 분리라 한다.</p><p>Student 클래스의 경우 변경 사유가 될 수 있는 것은 학생의 고유 정보, DB 스키마, 출력 형식의 변화 등 3가지다.</p><p>따라서 Student 클래스는 학생 고유의 역할을 수행하게끔 변경하고 학생 클래스의 인스턴스를 DB에 저장하거나 읽어들이는 역할을 담당하는 학생 DAO 클래스, 출석부와 성적표에 출력을 담당하는 성적표 클래스와 출석부 클래스로 분리하는 편이 좋다.</p><p>클래스들이 책임을 적절하게 분담하도록 변경하면 어떤 변화가 생겼을 때 영향을 최소화할 수 있다.</p><h3 id="산탄총-수술"><a href="#산탄총-수술" class="headerlink" title="산탄총 수술"></a>산탄총 수술</h3><p>지금까지는 한 클래스가 여러 가지 책임을 가진 상황이었다. 그런데 하나의 책임이 여러 개의 클래스들로 분산되어 있는 경우에도 단일 책임 원칙에 입각해 설계를 변경해야 하는 경우도 있다.</p><p>어떤 변경이 있을 때 하나가 아닌 여러 클래스를 변경해야 한다는 것이다.</p><p>클래스 하나하나를 모두 변경하지 않으면 프로그램이 정상적으로 동작하지 않고 에러가 발생할 수 있다. 하나의 책임이 여러 개의 클래스로 분리되어 있는 예는 로깅, 보안, 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능이 대표적이다.</p><p>횡단 관심에 속하는 기능은 대부분 시스템 핵심 기능(하나의 책임) 안에 포함되는 부가 기능(여러 개의 클래스로 분리)이다.</p><p>보통 부가 기능에 변경사항이 발생하면 해당 부가 기능을 실행하는 모든 핵심 기능에도 변경사항이 적용되어야 한다.</p><p>가령 시스템에서 실행하는 특정 메서드들의 실행 로그를 DB에 저장한다고 생각해보면 분명 메서드에 로그 기능을 실행하는 코드가 삽입되어 있을 것이다. 만약 로그를 DB에 저장하지 않고 파일로 저장하는 경우, 우선 로그 기능이 삽입된 메서드를 찾고 삽입된 로그 코드를 적절하게 변경해야 한다.</p><p>이러한 방식은 산탄총 수술을 하는 것과 같이 변경될 곳을 빠짐없이 모두 찾아 수정해야 한다. 이를 해결하는 것이 부가 기능을 별개의 클래스로 분리해 책임을 담당하게 하는 것이다. 즉, 여러 곳에 흩어진 공통 책임을 한 곳에 모으면서 응집도를 높인다.</p><p>그러나 이런 독립 클래스를 구현하더라도 구현된 기능들을 호출하고 사용하는 코드는 해당 기능을 사용하는 코드 어딘가에 포함될 수 밖에 없다.</p><h3 id="관심지향-프로그래밍과-횡단-관심-문제"><a href="#관심지향-프로그래밍과-횡단-관심-문제" class="headerlink" title="관심지향 프로그래밍과 횡단 관심 문제"></a>관심지향 프로그래밍과 횡단 관심 문제</h3><p>횡단 관심 문제를 해결하는 방법으로 관심지향 프로그래밍(AOP, Aspect-Oriented Programming) 기법이 있다.</p><p>AOP는 횡단 관심을 수행하는 코드를 aspect라는 특별한 객체로 모듈화하고 weaving이라는 작업을 통해 모듈화된 코드를 핵심 기능에 끼워넣을 수 있다. 이를 통해 기존의 코드를 전혀 변경하지 않고도 시스템 핵심 기능에서 필요한 부가 기능을 효과적으로 이용할 수 있다. 만약 횡단 관심에 변경이 생긴다면 해당 aspect만 수정하면 된다.</p><p>*연관 관계의 역할 이름은 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있다.</p><p>SRP와 고전적 설계 개념인 응집도와 결합도의 관계는 다음과 같다.</p><p>응집도 - 한 프로그램 요소(절차지향 관점에서는 프로그램 함수나 프로시저, 객체지향적 관점에서는 클래스나 메서드)가 얼마나 뭉쳐 있는가를 나타내는 척도다. 가령 프로시저 하나가 단일 기능을 실행하도록 문장이나 자료구조가 구성되었다면 해당 기능을 실행하기 위해 해당 구성 요소 어떤 것도 빠뜨리지 못할 것이다. 말 그대로 구성 요소들 사이의 응집력이 강하다. 이에 반해 프로시저가 여러 기능을 실행하도록 구성되어 있다면 각각의 기능을 실행하는 데 필요한 구성 요소들 사이는 서로 별다른 연관이 없을 것이다. 이런 경우에 SRP를 따르면 응집도는 높아진다.</p><p>결합도 - 프로그램 구성 요소들 사이가 얼마나 의존적인지를 나타내는 척도. 프로그램 안 프로시저 하나의 자료구조가 다른 형태로 변경되었을 때 이 프로시저를 사요여하는 곳도 변경되어야 한다면 이 두 프로시저는 결합도가 높다. 그러나 아무런 영향을 미치지 않는다면 결합도는 낮다고 한다.</p><p>설계의 기본 원칙은 응집도는 높고, 결합도는 낮게 하는 것으로 세운다. 응집도가 높으면 관련 기능이 한 곳에 모여있게 되는데, 이는 재사용과 유지 보수가 쉬워진다. 결합도가 낮아야 하는 이유는 결합도가 높은 시스템의 한 부분이 변경이 되면 이에 연관된 부분들도 같이 변경하거나 회귀 테스트를 실행해야 한다. 더군다나 변경하려는 부분을 독립적으로 떼어놓기 어렵기 때문에 재사용성이 낮으며 이해하기도 쉽지 않다.</p><p>응집도와 결합도는 서로 독립적인 개념이 아니라 밀접한 관계가 있는 개념. 관련된 것들을 한 곳에 두어 응집도를 높이면 자연스럽게 결합도는 낮아진다. 따라서 한 클래스로 하여금 단일 책임을 갖게하는 SRP에 따른 설계를 하면 응집도는 높아지고 더불어 결합도는 낮아진다.</p><p>*AOP 관련 용어<br>조인포인트(Jointpoint) - 애플리케이션 실행 중의 특정한 지점을 의미. 전형적인 조인포인트의 예로는 메서드 호출, 메서드 실행 자체, 클래스 초기화, 객체 생성 시점 등이 있다. 조인포인트는 AOP의 핵심 개념이며 애플리케이션의 어떤 지점에서 AOP를 사용해 추가적인 로직을 삽입할지를 정의한다.</p><p>어드바이스(Advice) - 특정 조인포인트에 실행하는 코드. 조인포인트 이전에 실행하는 Before 어드바이스와 이후에 실행하는 After 어드바이스를 비롯한 여러 종류의 어드바이스가 있다.</p><p>포인트컷(Pointcit) - 여러 조인포인트의 집합체. 언제 어드바이스를 실행할지 정의할 때 사용. 포인트컷을 만들면 애플리케이션 구성 요소에 어드바이스를 어떻게 적용할지 상세하게 제어할 수 있다. 가장 일반적으로 사용하는 조인포인트는 메서드 호출. 따라서 가장 일반적인 포인트컷은 특정 클래스에 있는 모든 메서드 호출로 구성된다. 종종 어드바이스 실행 지점을 좀 더 다양하게 제어할 필요가 있을 때는 복잡한 형태로 포인트컷을 구성할 수도 있다.</p><p>애스펙트(Aspect) - 어드바이스와 포인트컷을 조합한 조합물. 즉, 애플리케이션이 가져야 할 로직과 그것을 실행해야 하는 지점을 정의한 것</p><p>위빙(Weaving) - 애플리케이션 코드의 해당 지점에 애스펙트를 실제로 주입하는 과정. 컴파일 시점 AOP 솔루션은 이 작업을 컴파일 시점에 하며 빌드 중에 별도의 과정을 거친다. 마찬가지로 실행 시점 AOP 솔루션은 실행 중에 동적으로 위빙이 일어난다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;단일-책임-원칙-Single-Responsibility-Principle&quot;&gt;&lt;a href=&quot;#단일-책임-원칙-Single-Responsibility-Principle&quot; class=&quot;headerlink&quot; title=&quot;단일 책임 원칙(Sin
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>SOLID - 의존성 역전 원칙(Dependency Inversion Principle)</title>
    <link href="https://sengwoolee.dev/2020/05/24/2020-05-24-1/"/>
    <id>https://sengwoolee.dev/2020/05/24/2020-05-24-1/</id>
    <published>2020-05-24T14:09:23.000Z</published>
    <updated>2020-05-24T14:35:13.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="의존성-역전-원칙-Dependency-Inversion-Principle"><a href="#의존성-역전-원칙-Dependency-Inversion-Principle" class="headerlink" title="의존성 역전 원칙(Dependency Inversion Principle)"></a>의존성 역전 원칙(Dependency Inversion Principle)</h2><p>객체 사이에 서로 도움을 주고 받으면 의존 관계가 발생한다. 의존 역전 원칙 DIP는 이러한 관계를 맺을 때의 가이드라인에 해당한다.</p><p>DIP는 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것 보다는 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 원칙이다.</p><p>변하기 쉬운 것과 변하기 어려운 것은 정책, 전략과 같은 어떤 큰 흐름이나 개념 같은 추상적인 것은 변하기 어려운 것에 해당하고 구체적인 방식, 사물 등과 같은 것은 변하기 쉬운 것으로 구분하면 좋다.</p><p>객체지향의 관점에서는 변하기 어려운 추상적인 것들을 표현하는 수단으로 추상 클래스와 인터페이스가 있다.<br>DIP를 만족하려면 어떤 클래스가 도움을 받을 때 구체적인 클래스보다는 인터페이스나 추상 클래스와 의존 관계를 맺도록 설계해야 한다.<br>DIP를 만족하는 설계는 변화에 유연한 시스템이 된다.</p><p>인터페이스나 추상 클래스와 의존 관계를 맺도록 설계<br>인터페이스 = 변하지 않는 것<br>구체클래스 = 변하기 쉬운 것</p><p>DIP를 만족하면 의존성 주입(Dependency Injection)이라는 기술로 변화를 쉽게 수용할 수 있는 코드를 작성할 수 있다. 의존성 주입이란 말 그대로 클래스 외부에서 의존되는 것을 대상 객체에 인스턴스 변수에 주입하는 기술이다.<br>의존성 주입을 이용하면 대상 객체를 변경하지 않고도 외부에서 대상 객체의 외부 의존 객체를 바꿀 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Toy toy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToy</span><span class="params">(Toy toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toy = toy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toy.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kid 클래스에서 setToy 메서드로 아이가 가지고 노는 장난감을 바꿀 수 있다.<br>만약 로봇 장난감을 가지고 놀고 싶다면 다음 코드가 그 일을 해줄 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">extends</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Robot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Toy t = <span class="keyword">new</span> Robot();</span><br><span class="line">        Kid k = <span class="keyword">new</span> Kid();</span><br><span class="line">        k.setToy(t);</span><br><span class="line">        k.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>레고를 가지고 놀고 싶어진다면 다음 코드로 적용이 가능하다.<br>Kid, Toy, Robot 등 기존 코드에 영향을 받지 않고 장난감을 바꿀 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lego</span> <span class="keyword">extends</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Lego"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Toy t = <span class="keyword">new</span> Robot();</span><br><span class="line">        Kid k = <span class="keyword">new</span> Kid();</span><br><span class="line">        k.setToy(t);</span><br><span class="line">        k.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 Kid 클래스가 다음 클래스 다이어그램처럼 Robot 클래스와 연관 관계를 맺는다면 어떤 일이 발생할까</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Robot toy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToy</span><span class="params">(Robot toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toy = toy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toy.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Robot t = <span class="keyword">new</span> Robot();</span><br><span class="line">        Kid k = <span class="keyword">new</span> Kid();</span><br><span class="line">        k.setToy(t);</span><br><span class="line">        k.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 경우 레고로 장난감의 종류를 변경하려면 기존의 Kid 클래스가 다음처럼 바뀌어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lego toy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//아이가 가지고 노는 장난감의 종류만큼 메서드가 존재해야 함.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToy</span><span class="params">(Lego toy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toy = toy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toy.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>장난감을 바꿀 때마다 코드를 계속 바꿔야 한다. 즉 DIP의 위반이 OCP의 위반을 초래한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;의존성-역전-원칙-Dependency-Inversion-Principle&quot;&gt;&lt;a href=&quot;#의존성-역전-원칙-Dependency-Inversion-Principle&quot; class=&quot;headerlink&quot; title=&quot;의존성 역전 원칙(De
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>컴포넌트(Component)</title>
    <link href="https://sengwoolee.dev/2020/05/19/2020-05-19-2/"/>
    <id>https://sengwoolee.dev/2020/05/19/2020-05-19-2/</id>
    <published>2020-05-19T14:28:09.000Z</published>
    <updated>2020-05-19T15:57:25.026Z</updated>
    
    <content type="html"><![CDATA[<p>컴포넌트는 소프트웨어 시스템에서 독립적인 업무 또는 독립적인 기능을 수행하는 모듈로서 이후 시스템을 유지보수 하는데 있어 교체 가능한 부품이다.<br>소프트웨어 컴포넌트는 하드웨어의 그래픽카드와 같은 개념으로 독립적인 기능을 수행하는 소프트웨어 모듈이라고 말할 수 있으며 소프트웨어 컴포넌트는 컴포넌트란 말로 대체되어 사용되고 있다.</p><p>컴포넌트는 정의나 형태가 관점에 따라 다양하게 존재하지만 재사용 부품으로서의 컴포넌트가 되기 위해서는 아래의 내용을 만족해야 한다.<br>소스코드가 아닌 실행코드 기반으로 재사용할 수 있도록 이미 구현이 완료되어 있어야 한다.</p><p>컴포넌트는 용도, 유형, 기술표준과 인터페이스 등에 대한 정보들에 대해서 명세화가 되어 있어야 한다.<br>교체가능한 컴포넌트를 개발하기 위해서는 표준을 준수하여 개발해야 한다.<br>컴포넌트가 개발되어 배포될 때 관련 문서와 코드들이 독립적인 단위로 패키지화 되어 있어야 한다.<br>컴포넌트는 독립적인 업무 단위로 개발된 것이므로 사용자가 필요한 기능만을 패키지한 컴포넌트를 재사용할 수 있도록 독립적으로 배포 가능해야 한다.</p><p>컴포넌트, 클래스, 객체는 다른 개념으로 컴포넌트가 되기 위해서는 반드시 클래스나 객체로 만들어야 하는것은 아니다.<br>기존의 C나 Cobol로 개발된 모듈 또한 컴포넌트로 만들 수 있으나 현재의 컴포넌트 기술 표준들과 핵심개념들이 객체지향에서 비롯된 개념들이 많아 컴포넌트를 개발하는데 있어 객체지향 기술을 바탕으로 하는 것이 보다 효과적일 수 있다.<br>하나의 컴포넌트를 개발하기 위해서는 하나 이상의 클래스들을 바탕으로 개발할 수 있으며 이렇게 개발된 컴포넌트가 실행될 때 해당 컴포넌트의 인스턴스인 컴포넌트 객체가 수행된다.<br>이때 컴포넌트 내부에는 하나 이상의 클래스에 대응하는 하나 이상의 객체들이 수행되고 있는 것이라고 생각할 수 있다.</p><p>컴포넌트내의 정보는 외부로부터 은닉된다.<br>외부에서 접근할 수 있도록 컴포넌트가 제공하는 서비스를 정의한 인터페이스만을 제공하고 컴포넌트를 사용하기 위해서는 어떤 인터페이스를 사용해야 하는지만을 알 수 있다. 따라서 인터페이스는 외부와의 연결을 위해 반드시 존재해야만 하며 이처럼 컴포넌트가 내부 정보를 숨기고 인터페이스만을 제공함으로써 소프트웨어도 하드웨어처럼 조립 기반으로 갈 수 있게 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;컴포넌트는 소프트웨어 시스템에서 독립적인 업무 또는 독립적인 기능을 수행하는 모듈로서 이후 시스템을 유지보수 하는데 있어 교체 가능한 부품이다.&lt;br&gt;소프트웨어 컴포넌트는 하드웨어의 그래픽카드와 같은 개념으로 독립적인 기능을 수행하는 소프트웨어 
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 인터프리터 패턴(Interpreter Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/19/2020-05-19-1/"/>
    <id>https://sengwoolee.dev/2020/05/19/2020-05-19-1/</id>
    <published>2020-05-18T15:30:48.000Z</published>
    <updated>2020-05-18T15:39:52.427Z</updated>
    
    <content type="html"><![CDATA[<p>인터프리터 패턴은 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용한다. 이는 주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다.</p><p>활용</p><ol><li>SQL과 같은 데이터베이스 쿼리 언어</li><li>통신 프로토콜을 정의하기 위한 언어</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;인터프리터 패턴은 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용한다. 이는 주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 블랙보드 패턴(Blackboard Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/19/2020-05-18-1/"/>
    <id>https://sengwoolee.dev/2020/05/19/2020-05-18-1/</id>
    <published>2020-05-18T15:09:25.000Z</published>
    <updated>2020-05-18T15:24:56.915Z</updated>
    
    <content type="html"><![CDATA[<p>블랙보드 패턴은 결정 가능한 해결 전략이 알려지지 않은 문제에 유용합니다. 블랙보드 패턴은 3가지 주요 컴포넌트로 구성됩니다. </p><ol><li>블랙보드(Blackboard) : 솔루션의 객체를 포함하는 구조화된 전역 메모리</li><li>자식소스(Knowledge Source) : 자체 표현을 가진 특수 모듈</li><li>제어 컴포넌트(Control Component) : 모듈 선택, 설정 및 실행을 담당</li></ol><p>모든 컴포넌트는 블랙보드에 접근하며 컴포넌트는 블랙보드에 추가되는 새로운 데이터 객체를 생성할 수 있다. 컴포넌트는 블랙보드에서 특정 종류의 데이터를 찾으며 기존의 지식 소스와의 패턴 매칭으로 데이터를 찾는다.</p><p>활용</p><ol><li>음성 인식</li><li>차량 식별 및 추적</li><li>단백질 구조 식별</li><li>수중 음파 탐지기 신호 해석</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;블랙보드 패턴은 결정 가능한 해결 전략이 알려지지 않은 문제에 유용합니다. 블랙보드 패턴은 3가지 주요 컴포넌트로 구성됩니다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;블랙보드(Blackboard) : 솔루션의 객체를 포함하는 구조화된 전역 메모리&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 모델,뷰,컨트롤러 패턴(Model-View-Controller Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/17/2020-05-17-1/"/>
    <id>https://sengwoolee.dev/2020/05/17/2020-05-17-1/</id>
    <published>2020-05-17T10:56:18.000Z</published>
    <updated>2020-05-17T11:00:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>모델, 뷰, 컨트롤러 패턴은 MVC패턴이라고도 한다. 대화형 애플리케이션을 다음의 3 부분으로 나눈다. </p><ol><li>모델(Model) - 핵심 기능과 데이터를 포함한다.</li><li>뷰(View) - 사용자에게 정보를 표시한다.</li><li>컨트롤러(Controller) - 사용자로부터의 입력을 처리한다.<br>사용자에게 정보가 제공되는 방식과 사용자로부터 받아 들여지는 방식에서 정보의 내부적인 표현을 분리하기 위해 나누어진다. 이는 컴포넌트를 분리하며 코드의 효율적인 재사용을 가능케한다.</li></ol><p>활용</p><ol><li>일반적인 웹 애플리케이션 설계 아키텍쳐</li><li>Django나 Rails와 같은 프레임워크</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;모델, 뷰, 컨트롤러 패턴은 MVC패턴이라고도 한다. 대화형 애플리케이션을 다음의 3 부분으로 나눈다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;모델(Model) - 핵심 기능과 데이터를 포함한다.&lt;/li&gt;
&lt;li&gt;뷰(View) - 사용자에게 정보를 표시한다.&lt;
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 이벤트,버스 패턴(Event-Bus Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/16/2020-05-16-1/"/>
    <id>https://sengwoolee.dev/2020/05/16/2020-05-16-1/</id>
    <published>2020-05-16T14:17:01.000Z</published>
    <updated>2020-05-17T10:56:26.533Z</updated>
    
    <content type="html"><![CDATA[<p>이벤트,버스 패턴은 주로 이벤트를 처리하며 이벤트 소스(event source), 이벤트 리스너(event listener), 채널(channel) 그리고 이벤트 버스(event bus)의 4가지 주요 컴포넌트들을 갖는다. 소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행(publish)하며 리스너는 특정 채널에서 메시지를 구독(subcribe)한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.</p><p>활용</p><ol><li>안드로이드 개발</li><li>알림 서비스</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이벤트,버스 패턴은 주로 이벤트를 처리하며 이벤트 소스(event source), 이벤트 리스너(event listener), 채널(channel) 그리고 이벤트 버스(event bus)의 4가지 주요 컴포넌트들을 갖는다. 소스는 이벤트 버스를 
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 피어 투 피어 패턴(Peer-To-Peer Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/14/2020-05-14-1/"/>
    <id>https://sengwoolee.dev/2020/05/14/2020-05-14-1/</id>
    <published>2020-05-14T14:12:31.000Z</published>
    <updated>2020-05-17T10:56:31.600Z</updated>
    
    <content type="html"><![CDATA[<p>피어 투 피어 패턴은 각 컴포넌트를 피어로 부른다. 피어는 클라이언트로서 피어에게 서비스를 요청할 수도 있고 서버로서 각 피어에게 서비스를 제공할 수도 있다. 피어는 클라이언트 또는 서버 혹은 둘 모두로서 동작할 수 있으며 시간이 지남에 따라 역할이 유동적으로 바뀔 수 있다.</p><p>활용</p><ol><li>Gnutella나 G2와 같은 파일 공유 네트워크</li><li>P2PTV나 PDTP와 같은 멀티미디어 프로토콜</li><li>Spotify와 같은 독점적 멀티미디어 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;피어 투 피어 패턴은 각 컴포넌트를 피어로 부른다. 피어는 클라이언트로서 피어에게 서비스를 요청할 수도 있고 서버로서 각 피어에게 서비스를 제공할 수도 있다. 피어는 클라이언트 또는 서버 혹은 둘 모두로서 동작할 수 있으며 시간이 지남에 따라 역
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 브로커 패턴(Broker Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/11/2020-05-11-1/"/>
    <id>https://sengwoolee.dev/2020/05/11/2020-05-11-1/</id>
    <published>2020-05-11T13:52:26.000Z</published>
    <updated>2020-05-14T14:13:20.454Z</updated>
    
    <content type="html"><![CDATA[<p>브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호작용 할 수 있다. 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 한다.<br>서버는 자신의 기능들을 브로커에 넘겨주며 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리디렉션한다.</p><p>활용</p><ol><li>Apache ActiveMQ, Apache Kafka, RabbitMQ, JBoss Messaging - 메시지 브로커 소프트웨어</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호작용 할 수 있다. 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 한다.&lt;br&gt;서버는 자신의 기능들을 브로커에 넘겨주
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 파이프-필터 패턴(Pipe-Filter Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/10/2020-05-10-1/"/>
    <id>https://sengwoolee.dev/2020/05/10/2020-05-10-1/</id>
    <published>2020-05-10T07:37:04.000Z</published>
    <updated>2020-05-10T07:44:58.721Z</updated>
    
    <content type="html"><![CDATA[<p>파이프 필터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다. 각 처리 과정은 필터 컴포넌트에서 이루어지며 처리되는 데이터는 파이프를 통해 흐른다. 이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.</p><p>활용 </p><ol><li>컴파일러, 연속한 필터들은 어휘 분석, 파싱, 의미 분석, 코드 생성을 수행한다.</li><li>생물정보학에서의 워크플로우</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;파이프 필터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다. 각 처리 과정은 필터 컴포넌트에서 이루어지며 처리되는 데이터는 파이프를 통해 흐른다. 이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.&lt;/p&gt;
&lt;p&gt;활용 
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 마스터-슬레이브 패턴(Master-Slave Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/09/2020-05-09-1/"/>
    <id>https://sengwoolee.dev/2020/05/09/2020-05-09-1/</id>
    <published>2020-05-09T05:41:02.000Z</published>
    <updated>2020-05-09T05:58:10.771Z</updated>
    
    <content type="html"><![CDATA[<p>마스터-슬레이브 패턴은 마스터와 슬레이브 두 부분으로 구성된다. 마스터 컴포넌트는 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업을 분산하고 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.</p><p>활용</p><ol><li>데이터베이스 복제에서 마스터 데이터베이스는 신뢰할 수 있는 데이터 소스로 간주되며 슬레이브 데이터베이스는 마스터 데이터베이스와 동기화된다.</li><li>컴퓨터 시스템에서 버스와 연결된 주변장치 (마스터 드라이버와 슬레이브 드라이버)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;마스터-슬레이브 패턴은 마스터와 슬레이브 두 부분으로 구성된다. 마스터 컴포넌트는 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업을 분산하고 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.&lt;/p&gt;
&lt;p&gt;활용&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;데이터베
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 클라이언트-서버 패턴(Client-Server Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/06/2020-05-06-1/"/>
    <id>https://sengwoolee.dev/2020/05/06/2020-05-06-1/</id>
    <published>2020-05-06T14:33:02.000Z</published>
    <updated>2020-05-06T14:36:07.053Z</updated>
    
    <content type="html"><![CDATA[<p>클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에 적절한 서비스를 제공한다. 또한 서버는 계속 클라이언트로부터 요청을 대기한다.</p><p>활용</p><ol><li>이메일</li><li>문서 공유 및 은행 등의 온라인 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에 적절한 서비스를 제공한다. 또한 서버는 계속 클라이언트로
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처 패턴 - 계층화 패턴(Layered Pattern)</title>
    <link href="https://sengwoolee.dev/2020/05/05/2020-05-05-2/"/>
    <id>https://sengwoolee.dev/2020/05/05/2020-05-05-2/</id>
    <published>2020-05-05T12:39:55.000Z</published>
    <updated>2020-05-05T12:44:58.700Z</updated>
    
    <content type="html"><![CDATA[<p>이 패턴은 n-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다. 각 하위 모듈들은 특정한 수준의 추상화를 제공한다. 각 계층은 다음 상위 계층에 서비스를 제공한다. </p><p>일반적인 정보 시스템에서 공통적으로 볼 수 있는 계층 4가지는 다음과 같다.</p><ol><li>프레젠테이션 계층(Presentation Layer) / UI 계층(UI Layer)</li><li>애플리케이션 계층(Application Layer) / 서비스 계층(Service Layer)</li><li>비즈니스 논리 계층(Business Logic Layer) / 도메인 계층(Domain Layer)</li><li>데이터 접근 계층(Data Access Layer) / 영속 계층 (Persistence Layer)</li></ol><p>활용</p><ol><li>일반적인 데스크톱 애플리케이션</li><li>E-Commerce 웹 애플리케이션</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 패턴은 n-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다. 각 하위 모듈들은 특정한 수준의 추상화를 제공한다. 각 계층은 다음 상위 계층에 서비스를 제공한다. &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>소프트웨어 아키텍처</title>
    <link href="https://sengwoolee.dev/2020/05/05/2020-05-05-1/"/>
    <id>https://sengwoolee.dev/2020/05/05/2020-05-05-1/</id>
    <published>2020-05-05T12:32:23.000Z</published>
    <updated>2020-05-05T12:38:43.902Z</updated>
    
    <content type="html"><![CDATA[<p>SW 컴포넌트 사이의 상호관계를 설계하고 정의한 시스템 구조이다.</p><h3 id="소프트웨어-아키텍처의-특징"><a href="#소프트웨어-아키텍처의-특징" class="headerlink" title="소프트웨어 아키텍처의 특징"></a>소프트웨어 아키텍처의 특징</h3><ol><li>간략성<br> 이해하고 추론할 수 있을 정도의 간결성을 유지</li><li>추상화<br> 시스템의 추상적인 표현을 사용</li><li>가시성<br> 시스템이 포함해야 하는 것들을 가시화</li></ol><h3 id="소프트웨어-아키텍처-구성요소"><a href="#소프트웨어-아키텍처-구성요소" class="headerlink" title="소프트웨어 아키텍처 구성요소"></a>소프트웨어 아키텍처 구성요소</h3><ol><li>Architecture Description(AD)<br> 아키텍처를 기록하기 위한 산출물을 의미한다.<br> 하나의 AD는 System의 하나 이상의 View로 구성되어 있다.</li><li>이해관계자<br> 소프트웨어 시스템 개발에 관련된 모든 사람과 조직을 의미하며 고객 개발자 프로젝트 관리자 등을 포함한다.</li><li>관심사<br> 동일한 시스템에 대해 서로 다른 이해관계자의 의견이다.</li><li>관점<br> 서로 다른 역할이나 책임으로 시스템이나 산출물에 대한 서로 다른 관점이다.</li><li>뷰<br> 이해 관계자들가 이들이 가지는 생각이나 견해로부터 전체 시스템을 표현한다.<br> (4 + 1 View)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SW 컴포넌트 사이의 상호관계를 설계하고 정의한 시스템 구조이다.&lt;/p&gt;
&lt;h3 id=&quot;소프트웨어-아키텍처의-특징&quot;&gt;&lt;a href=&quot;#소프트웨어-아키텍처의-특징&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어 아키텍처의 특징&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Software Engineering" scheme="https://sengwoolee.dev/categories/Software-Engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7 Apache SSL인증서 적용 (Certbot, Let&#39;s encrypt)</title>
    <link href="https://sengwoolee.dev/2020/05/02/2020-05-04-1/"/>
    <id>https://sengwoolee.dev/2020/05/02/2020-05-04-1/</id>
    <published>2020-05-02T08:37:29.000Z</published>
    <updated>2020-05-05T12:22:47.588Z</updated>
    
    <content type="html"><![CDATA[<p>환경 : CentOS7 / Apache</p><p>EPEL 저장소 활성화 및 apache용 certbot 설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install certbot python2-certbot-apache</span><br></pre></td></tr></table></figure><p>certbot에서 apache를 기반으로 자동구성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache</span><br></pre></td></tr></table></figure><p>certbot에서 apache를 수동으로 구성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --apache certonly</span><br></pre></td></tr></table></figure><p>certbot을 설정하여 구성 완료 후 문제가 없을 경우 아래 메시지가 출력된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">/etc/letsencrypt/live/sengwoolee.dev/fullchain.pem</span><br><span class="line">Your key file has been saved at:</span><br><span class="line">/etc/letsencrypt/live/sengwoolee.dev/privkey.pem</span><br></pre></td></tr></table></figure><p>apache 서비스 재시작</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure><p>certbot 인증서 자동 갱신 테스트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --dry-run</span><br></pre></td></tr></table></figure><p>자동갱신 추가</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>아래 내용 작성 후 저장<br>0       0,12    *       *       *       python -c ‘import random; import time; time.sleep(random.random() * 3600)’ &amp;&amp; certbot renew</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;환경 : CentOS7 / Apache&lt;/p&gt;
&lt;p&gt;EPEL 저장소 활성화 및 apache용 certbot 설치&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu Errors were encountered while processing 해결</title>
    <link href="https://sengwoolee.dev/2020/05/01/2020-05-01-1/"/>
    <id>https://sengwoolee.dev/2020/05/01/2020-05-01-1/</id>
    <published>2020-05-01T14:11:49.000Z</published>
    <updated>2020-05-01T14:13:59.615Z</updated>
    
    <content type="html"><![CDATA[<p>dpkg 기록 삭제</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/dpkg/info/*</span><br></pre></td></tr></table></figure><p>dpkg 재설정</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --configure<span class="_">-a</span></span><br></pre></td></tr></table></figure><p>업데이트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dpkg 기록 삭제&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>IaaS, PaaS, SaaS</title>
    <link href="https://sengwoolee.dev/2020/04/28/2020-04-28-1/"/>
    <id>https://sengwoolee.dev/2020/04/28/2020-04-28-1/</id>
    <published>2020-04-28T14:29:33.000Z</published>
    <updated>2020-05-01T14:01:23.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS(Infrastructure as a Service)"></a>IaaS(Infrastructure as a Service)</h2><p>서버를 운영하기 위해서 필요한 서버 자원, IP, 네트워크, 스토리지, 전력 등등 을 가상의 환경에서 쉽고 편하게 사용할 수 있도록 서비스 형태로 제공한다. 기존 서버 호스팅보다 하드웨어 확장성이 좋고 탄력적이며 빠른 제공을 할 수 있는 가상화 기술을 이용한다. Pass와 Saas의 기반이 된다.</p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS(Platform as a Service)"></a>PaaS(Platform as a Service)</h2><p>IaaS를 기본으로 개발툴과 기능, 애플리케이션 배포 등 개발환경에 부가적인 서비스를 안전하게 제공하는 것이다. 미들웨어와 데이터베이스 관리, 애널리틱스 혹은 운영체제 등이 포함된다. 개발자가 애플리케이션을 개발하고 배포하는데 필요한 모든 것들을 제공해야 한다. PaaS를 이용하면 개발자는 기반 인프라스트럭처를 프로비저닝할 필요가 없다.</p><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS(Software as a Service)"></a>SaaS(Software as a Service)</h2><p>서드파티가 호스팅 방식으로 소프트웨어를 제공하는 것이다. 사용자는 내부 구성을 관리할 필요가 없다. 이메일이나 CRM 소프트웨어 등에서 널리 사용된다.<br>머신 혹은 서버를 기준으로 소프트웨어 라이선스를 구매해 직접 사용하던 기존의 구매 방식과 차별화된 서비스를 제공한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IaaS-Infrastructure-as-a-Service&quot;&gt;&lt;a href=&quot;#IaaS-Infrastructure-as-a-Service&quot; class=&quot;headerlink&quot; title=&quot;IaaS(Infrastructure as a Ser
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>데이터베이스 정규화, 반정규화</title>
    <link href="https://sengwoolee.dev/2020/04/26/2020-04-26-1/"/>
    <id>https://sengwoolee.dev/2020/04/26/2020-04-26-1/</id>
    <published>2020-04-26T11:09:57.000Z</published>
    <updated>2020-04-27T13:56:22.535Z</updated>
    
    <content type="html"><![CDATA[<p>데이터베이스의 정규화, 반정규화에 대해 작성한다.</p><ol><li>정규화(Normalization)<br>정규화는 데이터의 중복성을 제거하여 여러 엔티티의 조인이 발생하는 데이터베이스 환경에서 성능을 향상시키기 위한 데이터 구조화 프로세스를 말한다.</li></ol><p>정규화 단계<br>-제1정규화<br>중복되는 컬럼을 제거한다.<br>-제2정규화<br>종속되는 값을 제거한다.<br>-제3정규화<br>엔티티에 맞는 데이터로 분리한다.</p><ol start="2"><li>반정규화(역정규화, Denormalization)<br>정규화로 인해 테이블 수가 증가하면 다수의 조인이 발생함에 따라 성능 저하가 발생할 수 있다.<br>이 문제를 해결하고자 정규화 과정이 모두 마무리된 다음 반정규화를 실시한다.<br>단 테이벌을 합치는 것만이 반정규화는 아니다.</li></ol><p>-그룹에 대한 합계 값을 미리 계산하여 테이블에 저장<br>(기존 테이블에 sum 하는것이 아니라 별도의 통계 테이블을 생성)<br>-하나의 테이블에서 자주 사용되는 레코드와 그렇지 않은 행들을 분리<br>-자주 조인하여 사용하는 컬럼을 중복제거하여 하나의 테이블로 생성</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;데이터베이스의 정규화, 반정규화에 대해 작성한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;정규화(Normalization)&lt;br&gt;정규화는 데이터의 중복성을 제거하여 여러 엔티티의 조인이 발생하는 데이터베이스 환경에서 성능을 향상시키기 위한 데이터 구조화 프로세스
      
    
    </summary>
    
    
      <category term="Database" scheme="https://sengwoolee.dev/categories/Database/"/>
    
    
  </entry>
  
  <entry>
    <title>boilerplate</title>
    <link href="https://sengwoolee.dev/2020/04/25/2020-04-25-2/"/>
    <id>https://sengwoolee.dev/2020/04/25/2020-04-25-2/</id>
    <published>2020-04-25T13:30:20.000Z</published>
    <updated>2020-04-25T13:35:02.728Z</updated>
    
    <content type="html"><![CDATA[<p>보일러플레이트(boilerplate)는 변경 없이 재사용할 수 있는 저작품을 의미하며,<br>프로그래밍에서는 상용구 코드를 의미한다.<br>어떤 동작을 수행하기 위해 사전에 작성해야 하는 코드로서<br>자바에서는 클래스의 getter, setter 메소드를 말한다.</p><p>보일러 플레이트의 특징은 다음과 같다.</p><ol><li>최소한의 변경으로 재사용할 수 있는것</li><li>적은 수정만으로 여러 곳에 활용이 가능한 코드, 문구</li><li>각종 문서에서 반복적으로 인용되는 문서의 한 부분</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;보일러플레이트(boilerplate)는 변경 없이 재사용할 수 있는 저작품을 의미하며,&lt;br&gt;프로그래밍에서는 상용구 코드를 의미한다.&lt;br&gt;어떤 동작을 수행하기 위해 사전에 작성해야 하는 코드로서&lt;br&gt;자바에서는 클래스의 getter, sette
      
    
    </summary>
    
    
      <category term="Development" scheme="https://sengwoolee.dev/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>프레임워크 Express, Koa, Hapi</title>
    <link href="https://sengwoolee.dev/2020/04/25/2020-04-25-1/"/>
    <id>https://sengwoolee.dev/2020/04/25/2020-04-25-1/</id>
    <published>2020-04-25T13:15:16.000Z</published>
    <updated>2020-04-25T13:29:02.299Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Express<br>Node.js 프레임워크 중 커뮤니티가 가장 크다.<br>StrongLoop에 의해 관리되고 있다.<br>내장 라우터로 코드를 쉽게 재사용할 수 있다.</li></ol><p>내장된 에러 핸들링이 없다.<br>다른 프레임워크에 비해 메모리를 많이 차지한다.</p><ol start="2"><li>Koa<br>다른 프레임워크에 비해 미들웨어 작성이 쉽다.<br>기본적으로 뼈대 프레임워크라서 개발자가 필요한 미들웨어만 구성해 사용할 수 있다.<br>ES6 제너레이터를 사용할 수 있다.</li></ol><p>아직 불안정하며 많은 개발이 진행중이다.<br>미들웨어를 직접 작성할 수 있는게 장점이자 단점이다.</p><ol start="3"><li>Hapi<br>코드보다 설정을 더 많이 해야 한다.<br>견고함과 재사용성을 요구하는 큰 규모 팀에서 흔하게 사용된다.<br>월마트랩에서 만들고 이름있는 회사에서 많이 쓰고 있어서 검증되었다고 보는 편이다.</li></ol><p>크고 복잡한 어플리케이션에 특화되어 있다.<br>보일러플레이트로 작성해야 할 코드가 많아서 작은 웹앱에서 쓰기는 불편하고 예제 및 hapi로 작성된 오픈소스 앱도 적다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Express&lt;br&gt;Node.js 프레임워크 중 커뮤니티가 가장 크다.&lt;br&gt;StrongLoop에 의해 관리되고 있다.&lt;br&gt;내장 라우터로 코드를 쉽게 재사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;내장된 에러 핸들링이 없다.&lt;br&gt;다른
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://sengwoolee.dev/categories/Node-js/"/>
    
    
  </entry>
  
</feed>
